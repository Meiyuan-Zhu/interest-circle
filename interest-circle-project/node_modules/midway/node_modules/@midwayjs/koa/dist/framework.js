"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MidwayKoaFramework = exports.MidwayKoaBaseFramework = void 0;
const core_1 = require("@midwayjs/core");
const decorator_1 = require("@midwayjs/decorator");
const Router = require("@koa/router");
const koa = require("koa");
const logger_1 = require("./logger");
class MidwayKoaBaseFramework extends core_1.BaseFramework {
    constructor() {
        super(...arguments);
        this.controllerIds = [];
        this.prioritySortRouters = [];
    }
    getApplication() {
        return this.app;
    }
    /**
     * wrap controller string to middleware function
     * @param controllerMapping like FooController.index
     * @param routeArgsInfo
     * @param routerResponseData
     */
    generateController(controllerMapping, routeArgsInfo, routerResponseData) {
        const [controllerId, methodName] = controllerMapping.split('.');
        return async (ctx, next) => {
            const args = [ctx, next];
            if (Array.isArray(routeArgsInfo)) {
                await Promise.all(routeArgsInfo.map(async ({ index, type, propertyData }) => {
                    args[index] = await (0, core_1.extractKoaLikeValue)(type, propertyData)(ctx, next);
                }));
            }
            const controller = await ctx.requestContext.getAsync(controllerId);
            // eslint-disable-next-line prefer-spread
            const result = await controller[methodName].apply(controller, args);
            if (result !== undefined) {
                ctx.body = result;
            }
            if (ctx.body === undefined && !ctx.response._explicitStatus) {
                ctx.body = undefined;
            }
            // implement response decorator
            if (Array.isArray(routerResponseData) && routerResponseData.length) {
                for (const routerRes of routerResponseData) {
                    switch (routerRes.type) {
                        case decorator_1.WEB_RESPONSE_HTTP_CODE:
                            ctx.status = routerRes.code;
                            break;
                        case decorator_1.WEB_RESPONSE_HEADER:
                            for (const key in (routerRes === null || routerRes === void 0 ? void 0 : routerRes.setHeaders) || {}) {
                                ctx.set(key, routerRes.setHeaders[key]);
                            }
                            break;
                        case decorator_1.WEB_RESPONSE_CONTENT_TYPE:
                            ctx.type = routerRes.contentType;
                            break;
                        case decorator_1.WEB_RESPONSE_REDIRECT:
                            ctx.status = routerRes.code;
                            ctx.redirect(routerRes.url);
                            return;
                    }
                }
            }
        };
    }
    async generateMiddleware(middlewareId) {
        const mwIns = await this.getApplicationContext().getAsync(middlewareId);
        return mwIns.resolve();
    }
    async loadMidwayController() {
        const collector = new core_1.WebRouterCollector(this.getBaseDir());
        const routerTable = await collector.getRouterTable();
        const routerList = await collector.getRoutePriorityList();
        for (const routerInfo of routerList) {
            const providerId = routerInfo.controllerId;
            // controller id check
            if (this.controllerIds.indexOf(providerId) > -1) {
                throw new Error(`Controller identifier [${providerId}] already exists!`);
            }
            this.controllerIds.push(providerId);
            this.logger.debug(`Load Controller "${providerId}", prefix=${routerInfo.prefix}`);
            // new router
            const newRouter = this.createRouter({
                prefix: routerInfo.prefix,
                ...routerInfo.routerOptions,
            });
            // add router middleware
            const middlewares = routerInfo.middleware;
            await this.handlerWebMiddleware(middlewares, (middlewareImpl) => {
                newRouter.use(middlewareImpl);
            });
            // add route
            const routes = routerTable.get(routerInfo.prefix);
            for (const routeInfo of routes) {
                // get middleware
                const middlewares2 = routeInfo.middleware;
                const methodMiddlewares = [];
                await this.handlerWebMiddleware(middlewares2, (middlewareImpl) => {
                    methodMiddlewares.push(middlewareImpl);
                });
                if (this.getFrameworkType() === core_1.MidwayFrameworkType.WEB_KOA) {
                    if (typeof routeInfo.url === 'string' && /\*$/.test(routeInfo.url)) {
                        routeInfo.url = routeInfo.url.replace('*', '(.*)');
                    }
                }
                const routerArgs = [
                    routeInfo.routerName,
                    routeInfo.url,
                    ...methodMiddlewares,
                    this.generateController(routeInfo.handlerName, routeInfo.requestMetadata, routeInfo.responseMetadata),
                ];
                this.logger.debug(`Load Router "${routeInfo.requestMethod.toUpperCase()} ${routeInfo.url}"`);
                // apply controller from request context
                // eslint-disable-next-line prefer-spread
                newRouter[routeInfo.requestMethod].apply(newRouter, routerArgs);
            }
            this.app.use(newRouter.middleware());
        }
    }
    createRouter(routerOptions) {
        const router = new Router(routerOptions);
        router.prefix(routerOptions.prefix);
        return router;
    }
    async handlerWebMiddleware(middlewares, handlerCallback) {
        if (middlewares && middlewares.length) {
            for (const middleware of middlewares) {
                if (typeof middleware === 'function') {
                    // web function middleware
                    handlerCallback(middleware);
                }
                else {
                    const middlewareImpl = await this.getApplicationContext().getAsync(middleware);
                    if (middlewareImpl && typeof middlewareImpl.resolve === 'function') {
                        handlerCallback(middlewareImpl.resolve());
                    }
                }
            }
        }
    }
    getDefaultContextLoggerClass() {
        return logger_1.MidwayKoaContextLogger;
    }
}
exports.MidwayKoaBaseFramework = MidwayKoaBaseFramework;
class MidwayKoaFramework extends MidwayKoaBaseFramework {
    async applicationInitialize(options) {
        this.app = new koa();
        this.app.use(async (ctx, next) => {
            this.app.createAnonymousContext(ctx);
            await next();
        });
        this.defineApplicationProperties({
            generateController: (controllerMapping) => {
                return this.generateController(controllerMapping);
            },
            generateMiddleware: async (middlewareId) => {
                return this.generateMiddleware(middlewareId);
            },
        });
        // https config
        if (this.configurationOptions.key && this.configurationOptions.cert) {
            this.configurationOptions.key = core_1.PathFileUtil.getFileContentSync(this.configurationOptions.key);
            this.configurationOptions.cert = core_1.PathFileUtil.getFileContentSync(this.configurationOptions.cert);
            this.configurationOptions.ca = core_1.PathFileUtil.getFileContentSync(this.configurationOptions.ca);
            if (this.configurationOptions.http2) {
                this.server = require('http2').createSecureServer(this.configurationOptions, this.app.callback());
            }
            else {
                this.server = require('https').createServer(this.configurationOptions, this.app.callback());
            }
        }
        else {
            if (this.configurationOptions.http2) {
                this.server = require('http2').createServer(this.app.callback());
            }
            else {
                this.server = require('http').createServer(this.app.callback());
            }
        }
        // register httpServer to applicationContext
        this.applicationContext.registerObject(core_1.HTTP_SERVER_KEY, this.server);
    }
    async run() {
        await this.loadMidwayController();
        if (this.configurationOptions.port) {
            new Promise(resolve => {
                const args = [this.configurationOptions.port];
                if (this.configurationOptions.hostname) {
                    args.push(this.configurationOptions.hostname);
                }
                args.push(() => {
                    resolve();
                });
                this.server.listen(...args);
            });
        }
    }
    async beforeStop() {
        this.server.close();
    }
    getFrameworkType() {
        return core_1.MidwayFrameworkType.WEB_KOA;
    }
    getFrameworkName() {
        return 'midway:koa';
    }
    getServer() {
        return this.server;
    }
}
exports.MidwayKoaFramework = MidwayKoaFramework;
//# sourceMappingURL=framework.js.map