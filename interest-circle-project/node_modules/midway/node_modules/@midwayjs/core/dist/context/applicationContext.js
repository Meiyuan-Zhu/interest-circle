"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseApplicationContext = exports.ObjectDefinitionRegistry = void 0;
const properties_1 = require("../definitions/properties");
const managedResolverFactory_1 = require("./managedResolverFactory");
const notFoundError_1 = require("../common/notFoundError");
const util_1 = require("../util/");
const pathFileUtil_1 = require("../util/pathFileUtil");
const PREFIX = '_id_default_';
class ObjectDefinitionRegistry extends Map {
    constructor() {
        super(...arguments);
        this.singletonIds = [];
    }
    get identifiers() {
        const ids = [];
        for (const key of this.keys()) {
            if (key.indexOf(PREFIX) === -1) {
                ids.push(key);
            }
        }
        return ids;
    }
    get count() {
        return this.size;
    }
    getSingletonDefinitionIds() {
        return this.singletonIds;
    }
    getDefinitionByName(name) {
        const definitions = [];
        for (const v of this.values()) {
            const definition = v;
            if (definition.name === name) {
                definitions.push(definition);
            }
        }
        return definitions;
    }
    registerDefinition(identifier, definition) {
        if (definition.isSingletonScope()) {
            this.singletonIds.push(identifier);
        }
        this.set(identifier, definition);
    }
    getDefinition(identifier) {
        return this.get(identifier);
    }
    getDefinitionByPath(path) {
        for (const v of this.values()) {
            const definition = v;
            if (definition.path === path) {
                return definition;
            }
        }
        return null;
    }
    removeDefinition(identifier) {
        this.delete(identifier);
    }
    hasDefinition(identifier) {
        return this.has(identifier);
    }
    clearAll() {
        this.singletonIds = [];
        this.clear();
    }
    hasObject(identifier) {
        return this.has(PREFIX + identifier);
    }
    registerObject(identifier, target) {
        this.set(PREFIX + identifier, target);
    }
    getObject(identifier) {
        return this.get(PREFIX + identifier);
    }
}
exports.ObjectDefinitionRegistry = ObjectDefinitionRegistry;
class BaseApplicationContext {
    constructor(baseDir = '', parent) {
        this.readied = false;
        // 自己内部实现的，可注入的 feature(见 features)
        this.midwayIdentifiers = [];
        this._resolverFactory = null;
        this._registry = null;
        this._props = null;
        this._dependencyMap = null;
        this.baseDir = null;
        this.parent = null;
        this.messageSource = null;
        this.disableConflictCheck = false;
        this.parent = parent;
        this.baseDir = baseDir;
        this.init();
    }
    get dependencyMap() {
        if (!this._dependencyMap) {
            this._dependencyMap = new Map();
        }
        return this._dependencyMap;
    }
    get props() {
        if (!this._props) {
            this._props = new properties_1.ObjectProperties();
        }
        return this._props;
    }
    get registry() {
        if (!this._registry) {
            this._registry = new ObjectDefinitionRegistry();
        }
        return this._registry;
    }
    set registry(registry) {
        this._registry = registry;
    }
    getManagedResolverFactory() {
        if (!this._resolverFactory) {
            this._resolverFactory = new managedResolverFactory_1.ManagedResolverFactory(this);
        }
        return this._resolverFactory;
    }
    /**
     * 继承实现时需要调用super
     */
    init() { }
    async stop() {
        await this.getManagedResolverFactory().destroyCache();
        this.registry.clearAll();
        this.readied = false;
    }
    async ready() {
        await this.loadDefinitions();
        this.readied = true;
    }
    loadDefinitions() { }
    isAsync(identifier) {
        if (this.registry.hasDefinition(identifier)) {
            return this.registry.getDefinition(identifier).isAsync();
        }
        return false;
    }
    get(identifier, args) {
        const originIdentifier = identifier;
        // 因为在这里拿不到类名, NotFoundError 类的错误信息在 ManagedResolverFactory.ts createAsync 方法中增加错误类名
        identifier = (0, util_1.parsePrefix)(identifier);
        if (this.registry.hasObject(identifier)) {
            return this.registry.getObject(identifier);
        }
        if (this.isAsync(identifier)) {
            throw new Error(`${identifier} must use getAsync`);
        }
        let definition = this.registry.getDefinition(identifier);
        // find uuid
        if (!definition && /:/.test(identifier)) {
            identifier = identifier.replace(/^.*?:/, '');
            definition = this.registry.getDefinition(identifier);
        }
        if (!definition && this.parent) {
            if (this.parent.isAsync(identifier)) {
                throw new Error(`${identifier} must use getAsync`);
            }
            return this.parent.get(identifier, args);
        }
        if (!definition) {
            throw new notFoundError_1.NotFoundError(originIdentifier);
        }
        return this.getManagedResolverFactory().create({ definition, args });
    }
    async getAsync(identifier, args) {
        const originIdentifier = identifier;
        // 因为在这里拿不到类名, NotFoundError 类的错误信息在 ManagedResolverFactory.ts createAsync 方法中增加错误类名
        identifier = (0, util_1.parsePrefix)(identifier);
        if (this.registry.hasObject(identifier)) {
            return this.registry.getObject(identifier);
        }
        let definition = this.registry.getDefinition(identifier);
        // find uuid
        if (!definition && /:/.test(identifier)) {
            identifier = identifier.replace(/^.*?:/, '');
            definition = this.registry.getDefinition(identifier);
        }
        if (!definition && this.parent) {
            return this.parent.getAsync(identifier, args);
        }
        if (!definition) {
            throw new notFoundError_1.NotFoundError(originIdentifier);
        }
        return this.getManagedResolverFactory().createAsync({ definition, args });
    }
    get isReady() {
        return this.readied;
    }
    /**
     * proxy registry.registerDefinition
     * @param {ObjectIdentifier} identifier
     * @param {IObjectDefinition} definition
     */
    registerDefinition(identifier, definition) {
        if (!this.disableConflictCheck && this.registry.hasDefinition(identifier)) {
            const def = this.registry.getDefinition(identifier);
            if (definition.srcPath && def.srcPath) {
                if (!pathFileUtil_1.PathFileUtil.isPathEqual(definition.srcPath, def.srcPath)) {
                    throw new Error(`${identifier} path = ${definition.srcPath} already exist (${def.srcPath})!`);
                }
            }
        }
        this.registry.registerDefinition(identifier, definition);
        this.createObjectDependencyTree(identifier, definition);
    }
    /**
     * proxy registry.registerObject
     * @param {ObjectIdentifier} identifier
     * @param target
     */
    registerObject(identifier, target) {
        this.registry.registerObject(identifier, target);
    }
    /**
     * register handler after instance create
     * @param fn
     */
    afterEachCreated(fn) {
        this.getManagedResolverFactory().afterEachCreated(fn);
    }
    /**
     * register handler before instance create
     * @param fn
     */
    beforeEachCreated(fn) {
        this.getManagedResolverFactory().beforeEachCreated(fn);
    }
    createObjectDependencyTree(identifier, definition) {
        if (!this.dependencyMap.has(identifier)) {
            let constructorArgs = definition.constructorArgs || [];
            constructorArgs = constructorArgs
                .map(ref => {
                return ref.name;
            })
                .filter(name => {
                return !!name;
            });
            const properties = (definition.properties &&
                definition.properties.keys().map(key => {
                    return definition.properties.get(key).name;
                })) ||
                [];
            this.dependencyMap.set(identifier, {
                name: typeof definition.path !== 'string'
                    ? definition.path.name
                    : identifier,
                scope: definition.scope,
                constructorArgs,
                properties,
            });
        }
    }
}
exports.BaseApplicationContext = BaseApplicationContext;
//# sourceMappingURL=applicationContext.js.map