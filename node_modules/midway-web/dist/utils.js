"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
const ARGUMENT_NAMES = /([^\s,]+)/g;
function getParamNames(func) {
    const fnStr = func.toString().replace(STRIP_COMMENTS, '');
    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
    if (result === null) {
        result = [];
    }
    return result;
}
exports.getParamNames = getParamNames;
/**
 * Find methods on a given object
 *
 * @param {*} obj - object to enumerate on
 * @returns {string[]} - method names
 */
function getMethodNames(obj) {
    const enumerableOwnKeys = Object.keys(obj);
    const ownKeysOnObjectPrototype = Object.getOwnPropertyNames(Object.getPrototypeOf({}));
    // methods on obj itself should be always included
    const result = enumerableOwnKeys.filter(k => typeof obj[k] === 'function');
    // searching prototype chain for methods
    let proto = obj;
    do {
        proto = Object.getPrototypeOf(proto);
        const allOwnKeysOnPrototype = Object.getOwnPropertyNames(proto);
        // get methods from es6 class
        allOwnKeysOnPrototype.forEach(k => {
            if (typeof obj[k] === 'function' && k !== 'constructor') {
                result.push(k);
            }
        });
    } while (proto && proto !== Object.prototype);
    // leave out those methods on Object's prototype
    return result.filter(k => {
        return ownKeysOnObjectPrototype.indexOf(k) === -1;
    });
}
exports.getMethodNames = getMethodNames;
function isTypeScriptEnvironment() {
    return !!require.extensions['.ts'] || process.env.MIDWAY_TS_MODE === 'true';
}
exports.isTypeScriptEnvironment = isTypeScriptEnvironment;
//# sourceMappingURL=utils.js.map