"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const router_1 = require("@eggjs/router");
const decorator_1 = require("@midwayjs/decorator");
const extend = require("extend2");
const fs = require("fs");
const core_1 = require("@midwayjs/core");
const path = require("path");
const utils_1 = require("../utils");
const graphviz = require('graphviz');
const debug = require('debug')(`midway:loader:${process.pid}`);
const EggLoader = require('egg-core').EggLoader;
const TS_SRC_DIR = 'src';
const TS_TARGET_DIR = 'dist';
class MidwayWebLoader extends EggLoader {
    constructor(options) {
        super(options);
        this.controllerIds = [];
        this.prioritySortRouters = [];
    }
    /**
     * 判断是否是 ts 模式，在构造器内就会被执行
     */
    get isTsMode() {
        return !!this.app.options.typescript;
    }
    get applicationContext() {
        return this.containerLoader.getApplicationContext();
    }
    get pluginContext() {
        return this.containerLoader.getPluginContext();
    }
    loadApplicationContext() {
        // this.app.options.container 测试用例编写方便点
        const containerConfig = this.config.container || this.app.options.container || {};
        if (!containerConfig.loadDir) {
            // 如果没有配置，默认就把扫描目录改到 /src or /dist
            containerConfig.baseDir = this.baseDir;
        }
        // 在 super constructor 中会调用到getAppInfo，之后会被赋值
        // 如果是typescript会加上 dist 或者 src 目录
        this.containerLoader = new core_1.ContainerLoader({
            baseDir: this.baseDir,
            isTsMode: this.isTsMode,
        });
        this.containerLoader.initialize();
        this.applicationContext.registerObject('appDir', this.appDir);
        // 外部给容器里设置环境
        const envService = this.applicationContext.getEnvironmentService();
        envService.setCurrentEnvironment(this.appInfo.env);
        // 合并 egg config
        const configService = this.applicationContext.getConfigService();
        configService.addObject(this.app.config);
        // 如果没有关闭autoLoad 则进行load
        this.containerLoader.loadDirectory(containerConfig);
        this.containerLoader.registerHook(decorator_1.PLUGIN_KEY, (key) => {
            return this.app[key] || this.pluginContext.get(key);
        });
        this.containerLoader.registerHook(decorator_1.LOGGER_KEY, (key) => {
            if (this.app.getLogger) {
                return this.app.getLogger(key);
            }
            return this.options.logger;
        });
        // register app
        this.containerLoader.registerHook(decorator_1.APPLICATION_KEY, () => {
            return this.app;
        });
    }
    // loadPlugin -> loadConfig -> afterLoadConfig
    loadConfig() {
        this.loadPlugin();
        super.loadConfig();
    }
    // Get the real plugin path
    getPluginPath(plugin) {
        if (plugin && plugin.path) {
            return plugin.path;
        }
        const name = plugin.package || plugin.name;
        const lookupDirs = new Set();
        // 尝试在以下目录找到匹配的插件
        //  -> {APP_PATH}/node_modules
        //    -> {EGG_PATH}/node_modules
        //      -> $CWD/node_modules
        lookupDirs.add(path.join(this.appDir, 'node_modules'));
        // 到 egg 中查找，优先从外往里查找
        for (let i = this.eggPaths.length - 1; i >= 0; i--) {
            const eggPath = this.eggPaths[i];
            lookupDirs.add(path.join(eggPath, 'node_modules'));
        }
        // should find the $cwd/node_modules when test the plugins under npm3
        lookupDirs.add(path.join(process.cwd(), 'node_modules'));
        // support monorepo
        const monorepoPath = path.join(__dirname, '../../../');
        if (path.basename(monorepoPath) === 'node_modules') {
            lookupDirs.add(monorepoPath);
        }
        if (process.env.PLUGIN_PATH) {
            lookupDirs.add(path.join(process.env.PLUGIN_PATH, 'node_modules'));
        }
        for (let dir of lookupDirs) {
            dir = path.join(dir, name);
            if (fs.existsSync(dir)) {
                return fs.realpathSync(dir);
            }
        }
        throw new Error(`Can not find plugin ${name} in "${Array.from(lookupDirs).join(', ')}"`);
    }
    registerTypescriptDirectory() {
        const app = this.app;
        // 处理 ts 的初始路径
        this.appDir = this.baseDir = app.options.baseDir;
        if (this.isTsMode) {
            let dirSuffix = app.options.targetDir || TS_TARGET_DIR;
            if (utils_1.isTypeScriptEnvironment()) {
                dirSuffix = app.options.srcDir || TS_SRC_DIR;
                // 打开 egg 加载 ts 的开关
                process.env.EGG_TYPESCRIPT = 'true';
                debug(`typescript mode = true`);
            }
            const dir = path.join(app.options.baseDir, dirSuffix);
            this.baseDir = app.options.baseDir = this.options.baseDir = dir;
            this.options.logger.info(`in typescript current dir change to ${dir}`);
            debug(`in typescript current dir change to ${dir}`);
        }
    }
    getEggPaths() {
        if (!this.appDir) {
            // register appDir here
            this.registerTypescriptDirectory();
        }
        return super.getEggPaths();
    }
    getServerEnv() {
        let serverEnv;
        const envPath = path.join(this.appDir, 'config/env');
        if (fs.existsSync(envPath)) {
            serverEnv = fs.readFileSync(envPath, 'utf8').trim();
        }
        if (!serverEnv) {
            serverEnv = super.getServerEnv();
        }
        return serverEnv;
    }
    getAppInfo() {
        if (!this.appInfo) {
            const appInfo = super.getAppInfo();
            // ROOT == HOME in prod env
            this.appInfo = extend(true, appInfo, {
                root: appInfo.env === 'local' || appInfo.env === 'unittest'
                    ? this.appDir
                    : appInfo.root,
                appDir: this.appDir,
            });
        }
        return this.appInfo;
    }
    async preRegisterRouter(target, controllerId) {
        const controllerOption = decorator_1.getClassMetadata(decorator_1.CONTROLLER_KEY, target);
        const newRouter = this.createEggRouter(controllerOption);
        if (newRouter) {
            // implement middleware in controller
            const middlewares = controllerOption.routerOptions.middleware;
            await this.handlerWebMiddleware(middlewares, (middlewareImpl) => {
                newRouter.use(middlewareImpl);
            });
            // implement @get @post
            const webRouterInfo = decorator_1.getClassMetadata(decorator_1.WEB_ROUTER_KEY, target);
            if (webRouterInfo &&
                typeof webRouterInfo[Symbol.iterator] === 'function') {
                for (const webRouter of webRouterInfo) {
                    // get middleware
                    const middlewares2 = webRouter.middleware;
                    const methodMiddlwares = [];
                    await this.handlerWebMiddleware(middlewares2, (middlewareImpl) => {
                        methodMiddlwares.push(middlewareImpl);
                    });
                    // implement @body @query @param @body
                    const routeArgsInfo = decorator_1.getPropertyDataFromClass(decorator_1.WEB_ROUTER_PARAM_KEY, target, webRouter.method) || [];
                    const routerArgs = [
                        webRouter.routerName,
                        webRouter.path,
                        ...methodMiddlwares,
                        this.generateController(`${controllerId}.${webRouter.method}`, routeArgsInfo),
                    ];
                    // apply controller from request context
                    newRouter[webRouter.requestMethod].apply(newRouter, routerArgs);
                }
            }
            // sort for priority
            const priority = decorator_1.getClassMetadata(decorator_1.PRIORITY_KEY, target);
            this.prioritySortRouters.push({
                priority: priority || 0,
                router: newRouter,
            });
        }
    }
    async handlerWebMiddleware(middlewares, handlerCallback) {
        if (middlewares && middlewares.length) {
            for (const middleware of middlewares) {
                if (typeof middleware === 'function') {
                    // web function middleware
                    handlerCallback(middleware);
                }
                else {
                    const middlewareImpl = await this.applicationContext.getAsync(middleware);
                    if (middlewareImpl && typeof middlewareImpl.resolve === 'function') {
                        handlerCallback(middlewareImpl.resolve());
                    }
                }
            }
        }
    }
    /**
     * @param controllerOption
     */
    createEggRouter(controllerOption) {
        const { prefix, routerOptions: { sensitive }, } = controllerOption;
        if (prefix) {
            const router = new router_1.EggRouter({ sensitive }, this.app);
            router.prefix(prefix);
            return router;
        }
        return null;
    }
    async refreshContext() {
        await this.containerLoader.refresh();
    }
    async onClose() {
        await this.applicationContext.stop();
    }
    /**
     * wrap controller string to middleware function
     * @param controllerMapping like FooController.index
     */
    generateController(controllerMapping, routeArgsInfo) {
        const [controllerId, methodName] = controllerMapping.split('.');
        return async (ctx, next) => {
            const args = [ctx, next];
            if (Array.isArray(routeArgsInfo)) {
                await Promise.all(routeArgsInfo.map(async ({ index, extractValue }) => {
                    args[index] = await extractValue(ctx, next);
                }));
            }
            const controller = await ctx.requestContext.getAsync(controllerId);
            return controller[methodName].apply(controller, args);
        };
    }
    async loadMidwayController() {
        const controllerModules = decorator_1.listModule(decorator_1.CONTROLLER_KEY);
        // implement @controller
        for (const module of controllerModules) {
            let providerId = decorator_1.getProviderId(module);
            const meta = decorator_1.getClassMetadata(core_1.PRIVATE_META_DATA_KEY, module);
            if (providerId && meta) {
                providerId = core_1.util.generateProvideId(providerId, meta.namespace);
            }
            if (providerId) {
                if (this.controllerIds.indexOf(providerId) > -1) {
                    throw new Error(`controller identifier [${providerId}] is exists!`);
                }
                this.controllerIds.push(providerId);
                await this.preRegisterRouter(module, providerId);
            }
        }
        // implement @priority
        if (this.prioritySortRouters.length) {
            this.prioritySortRouters = this.prioritySortRouters.sort((routerA, routerB) => {
                return routerB.priority - routerA.priority;
            });
            this.prioritySortRouters.forEach(prioritySortRouter => {
                this.app.use(prioritySortRouter.router.middleware());
            });
        }
    }
    dumpDependency() {
        const g = graphviz.digraph('G');
        for (const [id, module,] of this.applicationContext.dependencyMap.entries()) {
            g.addNode(id, {
                label: `${id}(${module.name})\nscope:${module.scope}`,
                fontsize: '10',
            });
            module.properties.forEach(depId => {
                g.addEdge(id, depId, { label: `properties`, fontsize: '8' });
            });
            module.constructorArgs.forEach(depId => {
                g.addEdge(id, depId, { label: 'constructor', fontsize: '8' });
            });
        }
        try {
            return g.to_dot();
        }
        catch (err) {
            console.error('generate injection dependency tree fail, err = ', err.message);
        }
    }
}
exports.MidwayWebLoader = MidwayWebLoader;
//# sourceMappingURL=webLoader.js.map