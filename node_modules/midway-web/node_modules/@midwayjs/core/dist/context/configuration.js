"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerConfiguration = void 0;
const decorator_1 = require("@midwayjs/decorator");
const path_1 = require("path");
const util_1 = require("../util/");
const pathFileUtil_1 = require("../util/pathFileUtil");
const util = require("util");
const configuration_1 = require("../functional/configuration");
const debug = util.debuglog('midway:container:configuration');
class ContainerConfiguration {
    constructor(container) {
        this.loadDirs = [];
        this.loadModules = [];
        this.importObjects = {};
        // 新版本 configuration
        this.newVersion = false;
        this.container = container;
    }
    addLoadDir(dir) {
        this.loadDirs.push(dir);
    }
    addImports(imports = [], baseDir) {
        var _a, _b, _c;
        // 处理 imports
        for (const importPackage of imports) {
            if (!importPackage)
                continue;
            // for package
            const subContainerConfiguration = this.container.createConfiguration();
            if (typeof importPackage === 'string') {
                subContainerConfiguration.newVersion = false;
                const subPackageDir = this.resolvePackageBaseDir(importPackage, baseDir);
                debug(`\n---------- start load configuration from sub package "${importPackage}" ----------`);
                subContainerConfiguration.load(subPackageDir);
                debug(`---------- end load configuration from sub package "${importPackage}" ----------`);
            }
            else if ('Configuration' in importPackage) {
                subContainerConfiguration.newVersion = true;
                // component is object
                debug('\n---------- start load configuration from submodule" ----------');
                subContainerConfiguration.loadComponentObject(importPackage);
                debug(`---------- end load configuration from sub package "${importPackage}" ----------`);
            }
            else if ('component' in importPackage) {
                subContainerConfiguration.newVersion = true;
                if ((_a = importPackage) === null || _a === void 0 ? void 0 : _a.enabledEnvironment) {
                    if ((_c = (_b = importPackage) === null || _b === void 0 ? void 0 : _b.enabledEnvironment) === null || _c === void 0 ? void 0 : _c.includes(this.container.getCurrentEnv())) {
                        subContainerConfiguration.loadComponentObject(importPackage.component);
                    }
                }
                else {
                    subContainerConfiguration.loadComponentObject(importPackage.component);
                }
            }
            else {
                throw new Error('import module not a midway component, module =' +
                    util.inspect(importPackage));
            }
        }
    }
    addImportObjects(importObjects) {
        if (importObjects) {
            this.importObjects = importObjects;
        }
    }
    getImportObjects() {
        return this.importObjects;
    }
    addImportConfigs(importConfigs, baseDir) {
        if (importConfigs && importConfigs.length) {
            debug('   import configs %j from baseDir => "%s".', importConfigs, baseDir);
            this.container.getConfigService().add(importConfigs.map(importConfigPath => {
                if (typeof importConfigPath === 'string') {
                    if ((0, path_1.isAbsolute)(importConfigPath)) {
                        return importConfigPath;
                    }
                    else {
                        return (0, path_1.join)(baseDir || this.container.baseDir, importConfigPath);
                    }
                }
                else {
                    return importConfigPath;
                }
            }));
        }
    }
    resolvePackageBaseDir(packageName, baseDir) {
        // 把相对路径转为绝对路径
        if (pathFileUtil_1.PathFileUtil.isPath(packageName)) {
            if (!(0, path_1.isAbsolute)(packageName)) {
                packageName = (0, path_1.join)(baseDir || this.container.baseDir, packageName);
            }
            return packageName;
        }
        try {
            return (0, path_1.dirname)(require.resolve(packageName));
        }
        catch (e) {
            /* ignore */
        }
        return (0, path_1.join)(baseDir || this.container.baseDir, '../node_modules', packageName);
    }
    load(packageName) {
        let isSubDir = false;
        let packageBaseDir = this.resolvePackageBaseDir(packageName);
        // package name is a path
        if (packageName === packageBaseDir) {
            debug('load configuration.ts from "%s"', packageName);
        }
        else {
            // package name is a normal npm package
            debug('load configuration.ts in "%s" from "%s"', packageName, packageBaseDir);
        }
        let pkg = (0, util_1.safeRequire)((0, path_1.join)(packageBaseDir, 'package.json'));
        if (!pkg) {
            isSubDir = true;
            pkg = (0, util_1.safeRequire)((0, path_1.join)(packageBaseDir, '../', 'package.json'));
        }
        if (pkg) {
            debug('found package.json and name-version => "%s", from "%s".', `${pkg.name}-${pkg.version}`, packageBaseDir);
        }
        else {
            // no package.json
            debug('not found package.json from "%s".', packageBaseDir);
            debug(`will be load configuration.ts from "${packageBaseDir}/configuration" directly`);
        }
        let configuration;
        let cfgFile;
        let loadDir;
        if (pkg) {
            this.packageName = pkg.name;
            if (this.namespace !== decorator_1.MAIN_MODULE_KEY) {
                this.namespace =
                    pkg.midwayNamespace !== undefined ? pkg.midwayNamespace : pkg.name;
            }
            if (pkg.main && !isSubDir) {
                packageBaseDir = (0, path_1.dirname)((0, path_1.join)(packageBaseDir, pkg.main));
                cfgFile = (0, path_1.join)(packageBaseDir, 'configuration');
                configuration = (0, util_1.safeRequire)(cfgFile);
                debug('current case 1 => configuration file "%s".', cfgFile);
                loadDir = packageBaseDir;
            }
        }
        if (!configuration) {
            cfgFile = (0, path_1.join)(packageBaseDir, 'configuration');
            configuration = (0, util_1.safeRequire)(cfgFile);
            debug('current case 2 => configuration file "%s".', cfgFile);
            loadDir = packageBaseDir;
        }
        if (loadDir) {
            this.addLoadDir(loadDir);
            debug('   add loadDir => "%s".', loadDir);
            debug('   add namespace => "%s".', this.namespace);
        }
        debug('   has configuration file => %s.', !!configuration);
        this.loadConfiguration(configuration, packageBaseDir, cfgFile);
    }
    loadComponentObject(componentObject) {
        if (!componentObject || !componentObject['Configuration']) {
            return;
        }
        this.loadConfiguration(componentObject['Configuration'], '');
        let configurationOptions;
        if (componentObject['Configuration'] instanceof configuration_1.FunctionalConfiguration) {
            // 函数式写法
            configurationOptions =
                componentObject['Configuration'].getConfigurationOptions();
        }
        else {
            // 普通类写法
            configurationOptions = (0, decorator_1.getClassMetadata)(decorator_1.CONFIGURATION_KEY, componentObject['Configuration']);
        }
        const ns = configurationOptions.namespace || decorator_1.MAIN_MODULE_KEY;
        this.container.bindClass(componentObject, ns);
    }
    loadConfiguration(configuration, baseDir, filePath) {
        if (configuration) {
            // 可能导出多个
            const configurationExports = this.getConfigurationExport(configuration);
            if (!configurationExports.length)
                return;
            // 多个的情况，数据交给第一个保存
            for (let i = 0; i < configurationExports.length; i++) {
                const configurationExport = configurationExports[i];
                let configurationOptions;
                if (configurationExport instanceof configuration_1.FunctionalConfiguration) {
                    // 函数式写法
                    configurationOptions = configurationExport.getConfigurationOptions();
                }
                else {
                    // 普通类写法
                    configurationOptions = (0, decorator_1.getClassMetadata)(decorator_1.CONFIGURATION_KEY, configurationExport);
                }
                debug('   configuration export %j.', configurationOptions);
                if (configurationOptions) {
                    if (this.namespace !== decorator_1.MAIN_MODULE_KEY &&
                        configurationOptions.namespace !== undefined) {
                        this.namespace = configurationOptions.namespace;
                    }
                    if (!this.packageName) {
                        this.packageName = this.namespace;
                    }
                    if (i === 0 &&
                        this.container.containsConfiguration(this.packageName) &&
                        this.namespace !== '') {
                        debug(`   configuration "namespace(${this.namespace})/packageName(${this.packageName})" exist than ignore.`);
                        return;
                    }
                    else {
                        debug(`   configuration "namespace(${this.namespace})/packageName(${this.packageName})" not exist than add.`);
                        this.container.addConfiguration(this);
                    }
                    if (configurationOptions.directoryResolveFilter) {
                        this.container.addDirectoryFilter(configurationOptions.directoryResolveFilter);
                    }
                    if (i === 0 && this.namespace === decorator_1.MAIN_MODULE_KEY) {
                        // set conflictCheck
                        if (process.env.MIDWAY_ENABLE_CONFLICT_CHECK) {
                            configurationOptions.conflictCheck =
                                process.env.MIDWAY_ENABLE_CONFLICT_CHECK === 'true';
                        }
                        if (configurationOptions.conflictCheck === undefined) {
                            configurationOptions.conflictCheck = false;
                        }
                        this.container.disableConflictCheck =
                            !configurationOptions.conflictCheck;
                    }
                    this.addImports(configurationOptions.imports, baseDir);
                    this.addImportObjects(configurationOptions.importObjects);
                    this.addImportConfigs(configurationOptions.importConfigs, baseDir);
                    this.bindConfigurationClass(configurationExport, filePath);
                }
            }
        }
        else {
            if (this.namespace === decorator_1.MAIN_MODULE_KEY) {
                this.container.disableConflictCheck = true;
            }
            if (this.container.containsConfiguration(this.packageName) &&
                this.namespace !== '') {
                debug(`   configuration "namespace(${this.namespace})/packageName(${this.packageName})" exist than ignore.`);
                return;
            }
            else {
                debug(`   configuration "namespace(${this.namespace})/packageName(${this.packageName})" not exist than add.`);
                this.container.addConfiguration(this);
            }
        }
    }
    /**
     * 用于 ready 或者 stop 时处理 lifecycle 实现
     * @param clzz configuration class
     */
    bindConfigurationClass(clzz, filePath) {
        if (clzz instanceof configuration_1.FunctionalConfiguration) {
            // 函数式写法不需要绑定到容器
        }
        else {
            // 普通类写法
            const clzzName = `${decorator_1.LIFECYCLE_IDENTIFIER_PREFIX}${(0, decorator_1.classNamed)(clzz.name)}`;
            const id = (0, decorator_1.generateProvideId)(clzzName, this.namespace);
            (0, decorator_1.saveProviderId)(id, clzz, true);
            this.container.bind(id, clzz, {
                namespace: this.namespace,
                srcPath: filePath,
                scope: decorator_1.ScopeEnum.Singleton,
            });
        }
        // configuration 手动绑定去重
        const configurationMods = (0, decorator_1.listModule)(decorator_1.CONFIGURATION_KEY);
        const exists = configurationMods.find(mod => {
            return mod.target === clzz;
        });
        if (!exists) {
            (0, decorator_1.saveModule)(decorator_1.CONFIGURATION_KEY, {
                target: clzz,
                namespace: this.namespace,
            });
        }
    }
    getImportDirectory() {
        return this.loadDirs;
    }
    getConfigurationExport(exports) {
        const mods = [];
        if ((0, decorator_1.isClass)(exports) ||
            (0, decorator_1.isFunction)(exports) ||
            exports instanceof configuration_1.FunctionalConfiguration) {
            mods.push(exports);
        }
        else {
            for (const m in exports) {
                const module = exports[m];
                if ((0, decorator_1.isClass)(module) ||
                    (0, decorator_1.isFunction)(module) ||
                    module instanceof configuration_1.FunctionalConfiguration) {
                    mods.push(module);
                }
            }
        }
        return mods;
    }
}
exports.ContainerConfiguration = ContainerConfiguration;
//# sourceMappingURL=configuration.js.map