"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MidwayContainer = exports.clearContainerCache = void 0;
const decorator_1 = require("@midwayjs/decorator");
const configuration_1 = require("./configuration");
const constants_1 = require("../common/constants");
const interface_1 = require("../interface");
const configService_1 = require("../service/configService");
const environmentService_1 = require("../service/environmentService");
const pipeline_1 = require("../features/pipeline");
const resolverHandler_1 = require("./resolverHandler");
const glob_1 = require("@midwayjs/glob");
const applicationContext_1 = require("./applicationContext");
const util = require("util");
const reflectTool_1 = require("../common/reflectTool");
const objectDefinition_1 = require("../definitions/objectDefinition");
const functionDefinition_1 = require("../definitions/functionDefinition");
const managed_1 = require("./managed");
const aspectService_1 = require("../service/aspectService");
const DEFAULT_PATTERN = ['**/**.ts', '**/**.tsx', '**/**.js'];
const DEFAULT_IGNORE_PATTERN = [
    '**/**.d.ts',
    '**/logs/**',
    '**/run/**',
    '**/public/**',
    '**/app/view/**',
    '**/app/views/**',
    '**/app/extend/**',
    '**/node_modules/**',
    '**/**.test.ts',
    '**/**.test.js',
    '**/__test__/**',
];
const globalDebugLogger = util.debuglog('midway:container');
let containerIdx = 0;
function clearContainerCache() {
    MidwayContainer.parentDefinitionMetadata = null;
    MidwayContainer.parentApplicationContext = null;
}
exports.clearContainerCache = clearContainerCache;
class MidwayContainer extends applicationContext_1.BaseApplicationContext {
    constructor(baseDir = process.cwd(), parent) {
        super(baseDir, parent);
        this.debugLogger = globalDebugLogger;
        this.definitionMetadataList = [];
        // 仅仅用于兼容requestContainer的ctx
        this.ctx = {};
        this.configurationMap = new Map();
        // 特殊处理，按照 main 加载
        this.likeMainConfiguration = [];
        this.directoryFilterArray = [];
        this.attrMap = new Map();
        this.id = '00' + this.createContainerIdx();
        if (!MidwayContainer.parentApplicationContext) {
            MidwayContainer.parentApplicationContext = this;
        }
    }
    createContainerIdx() {
        return containerIdx++;
    }
    init() {
        this.initService();
        this.resolverHandler = new resolverHandler_1.ResolverHandler(this, this.getManagedResolverFactory());
        // 防止直接从applicationContext.getAsync or get对象实例时依赖当前上下文信息出错
        // ctx is in requestContainer
        this.registerObject(interface_1.REQUEST_CTX_KEY, this.ctx);
    }
    initService() {
        this.environmentService = new environmentService_1.MidwayEnvironmentService();
        this.configService = new configService_1.MidwayConfigService(this);
        this.aspectService = new aspectService_1.MidwayAspectService(this);
    }
    /**
     * load directory and traverse file to find bind class
     * @param opts
     */
    load(opts = { loadDir: [] }) {
        // 添加全局白名单
        this.midwayIdentifiers.push(decorator_1.PIPELINE_IDENTIFIER);
        this.debugLogger('main:create "Main Module" and "Main Configuration"');
        // create main module configuration
        const configuration = this.createConfiguration();
        configuration.namespace = decorator_1.MAIN_MODULE_KEY;
        this.debugLogger(`main:"Main Configuration" load from "${this.baseDir}"`);
        configuration.load(this.baseDir);
        // loadDir
        this.debugLogger('main:load directory');
        // auto load cache next time when loadDirectory invoked
        let loadDirKey = this.baseDir;
        const loadDirs = [].concat(opts.loadDir || []);
        MidwayContainer.parentDefinitionMetadata =
            MidwayContainer.parentDefinitionMetadata || new Map();
        if (loadDirs.length > 0) {
            loadDirKey = loadDirs.join('-');
        }
        // load configuration
        for (const [packageName, containerConfiguration] of this.configurationMap) {
            // 老版本 configuration 才加载
            if (containerConfiguration.newVersion === false) {
                // main 的需要 skip 掉
                if (containerConfiguration.namespace === decorator_1.MAIN_MODULE_KEY) {
                    continue;
                }
                this.debugLogger(`main:load configuration from ${packageName}`);
                this.loadConfiguration(opts, containerConfiguration);
            }
        }
        for (const containerConfiguration of this.likeMainConfiguration) {
            // 老版本 configuration 才加载
            if (containerConfiguration.newVersion === false) {
                this.loadConfiguration(opts, containerConfiguration);
            }
        }
        if (MidwayContainer.parentDefinitionMetadata.has(loadDirKey)) {
            this.restoreDefinitions(MidwayContainer.parentDefinitionMetadata.get(loadDirKey));
        }
        else {
            this.loadDirectory(opts);
            // 保存元信息最新的上下文中，供其他容器复用，减少重复扫描
            MidwayContainer.parentDefinitionMetadata.set(loadDirKey, this.getDefinitionMetaList());
        }
        this.debugLogger('main:main configuration register import objects');
        this.registerImportObjects(configuration.getImportObjects());
        // register base config hook
        this.registerDataHandler(decorator_1.CONFIG_KEY, (key) => {
            if (key === decorator_1.ALL) {
                return this.getConfigService().getConfiguration();
            }
            else {
                return this.getConfigService().getConfiguration(key);
            }
        });
    }
    // 加载模块
    loadDirectory(opts) {
        const loadDirs = [].concat(opts.loadDir || []);
        for (const dir of loadDirs) {
            const fileResults = (0, glob_1.run)(DEFAULT_PATTERN.concat(opts.pattern || []), {
                cwd: dir,
                ignore: DEFAULT_IGNORE_PATTERN.concat(opts.ignore || []),
            });
            for (const file of fileResults) {
                this.debugLogger(`\nmain:*********** binding "${file}" ***********`);
                this.debugLogger(`  namespace => "${opts.namespace}"`);
                if (this.directoryFilterArray.length) {
                    for (const resolveFilter of this.directoryFilterArray) {
                        if (typeof resolveFilter.pattern === 'string') {
                            if (file.includes(resolveFilter.pattern)) {
                                const exports = resolveFilter.ignoreRequire
                                    ? undefined
                                    : require(file);
                                resolveFilter.filter(exports, file, this);
                                continue;
                            }
                        }
                        else if ((0, decorator_1.isRegExp)(resolveFilter.pattern)) {
                            if (resolveFilter.pattern.test(file)) {
                                const exports = resolveFilter.ignoreRequire
                                    ? undefined
                                    : require(file);
                                resolveFilter.filter(exports, file, this);
                                continue;
                            }
                        }
                        const exports = require(file);
                        // add module to set
                        this.bindClass(exports, opts.namespace, file);
                        this.debugLogger(`  binding "${file}" end`);
                    }
                }
                else {
                    const exports = require(file);
                    // add module to set
                    this.bindClass(exports, opts.namespace, file);
                    this.debugLogger(`  binding "${file}" end`);
                }
            }
        }
    }
    bindClass(exports, namespace = '', filePath) {
        if ((0, decorator_1.isClass)(exports) || (0, decorator_1.isFunction)(exports)) {
            this.bindModule(exports, namespace, filePath);
        }
        else {
            for (const m in exports) {
                const module = exports[m];
                if ((0, decorator_1.isClass)(module) || (0, decorator_1.isFunction)(module)) {
                    this.bindModule(module, namespace, filePath);
                }
            }
        }
    }
    bind(identifier, target, options) {
        const definitionMeta = {};
        this.definitionMetadataList.push(definitionMeta);
        if ((0, decorator_1.isClass)(identifier) || (0, decorator_1.isFunction)(identifier)) {
            options = target;
            target = identifier;
            identifier = this.getIdentifier(target);
        }
        if ((0, decorator_1.isClass)(target)) {
            definitionMeta.definitionType = 'object';
        }
        else {
            definitionMeta.definitionType = 'function';
            if (!(0, decorator_1.isAsyncFunction)(target)) {
                definitionMeta.asynchronous = false;
            }
        }
        definitionMeta.path = target;
        definitionMeta.id = identifier;
        definitionMeta.srcPath = (options === null || options === void 0 ? void 0 : options.srcPath) || null;
        definitionMeta.namespace = (options === null || options === void 0 ? void 0 : options.namespace) || '';
        definitionMeta.scope = (options === null || options === void 0 ? void 0 : options.scope) || decorator_1.ScopeEnum.Request;
        definitionMeta.autowire = (options === null || options === void 0 ? void 0 : options.isAutowire) !== false;
        this.debugLogger(`  bind id => [${definitionMeta.id}]`);
        // inject constructArgs
        const constructorMetaData = (0, decorator_1.getConstructorInject)(target);
        if (constructorMetaData) {
            this.debugLogger(`inject constructor => length = ${target['length']}`);
            definitionMeta.constructorArgs = [];
            const maxLength = Math.max.apply(null, Object.keys(constructorMetaData));
            for (let i = 0; i < maxLength + 1; i++) {
                const propertyMeta = constructorMetaData[i];
                if (propertyMeta) {
                    definitionMeta.constructorArgs.push({
                        type: 'ref',
                        value: propertyMeta[0].value,
                        args: propertyMeta[0].args,
                    });
                }
                else {
                    definitionMeta.constructorArgs.push({
                        type: 'value',
                        value: propertyMeta === null || propertyMeta === void 0 ? void 0 : propertyMeta[0].value,
                    });
                }
            }
        }
        // inject properties
        const props = (0, reflectTool_1.recursiveGetPrototypeOf)(target);
        props.push(target);
        definitionMeta.properties = [];
        definitionMeta.handlerProps = [];
        for (const p of props) {
            const metaData = (0, reflectTool_1.getOwnMetadata)(decorator_1.TAGGED_PROP, p);
            if (metaData) {
                this.debugLogger(`  inject properties => [${Object.keys(metaData)}]`);
                for (const metaKey in metaData) {
                    for (const propertyMeta of metaData[metaKey]) {
                        definitionMeta.properties.push({
                            metaKey,
                            args: propertyMeta.args,
                            value: propertyMeta.value,
                        });
                    }
                }
            }
            const meta = (0, reflectTool_1.getOwnMetadata)(decorator_1.INJECT_CLASS_KEY_PREFIX, p);
            if (meta) {
                for (const [key, vals] of meta) {
                    if (Array.isArray(vals)) {
                        for (const val of vals) {
                            if (val.key !== undefined &&
                                val.key !== null &&
                                typeof val.propertyName === 'string') {
                                definitionMeta.handlerProps.push({
                                    handlerKey: decorator_1.DecoratorManager.removeDecoratorClassKeySuffix(key),
                                    prop: val,
                                });
                            }
                        }
                    }
                }
            }
        }
        this.convertOptionsToDefinition(options, definitionMeta);
        // 对象自定义的annotations可以覆盖默认的属性
        this.registerCustomBinding(definitionMeta, target);
        // 把源信息变成真正的对象定义
        this.restoreDefinition(definitionMeta);
    }
    restoreDefinition(definitionMeta) {
        let definition;
        if (definitionMeta.definitionType === 'object') {
            definition = new objectDefinition_1.ObjectDefinition();
        }
        else {
            definition = new functionDefinition_1.FunctionDefinition();
            if (!definitionMeta.asynchronous) {
                definition.asynchronous = false;
            }
        }
        definition.path = definitionMeta.path;
        definition.id = definitionMeta.id;
        definition.srcPath = definitionMeta.srcPath;
        definition.namespace = definitionMeta.namespace;
        this.debugLogger(`  bind id => [${definition.id}]`);
        // inject constructArgs
        if (definitionMeta.constructorArgs &&
            definitionMeta.constructorArgs.length) {
            for (const constructorInfo of definitionMeta.constructorArgs) {
                if (constructorInfo.type === 'ref') {
                    const refManagedIns = new managed_1.ManagedReference();
                    const name = constructorInfo.value;
                    refManagedIns.args = constructorInfo.args;
                    if (this.midwayIdentifiers.includes(name)) {
                        refManagedIns.name = name;
                    }
                    else {
                        refManagedIns.name = (0, decorator_1.generateProvideId)(name, definition.namespace);
                    }
                    definition.constructorArgs.push(refManagedIns);
                }
                else {
                    // inject empty value
                    const valueManagedIns = new managed_1.ManagedValue();
                    valueManagedIns.valueType = constructorInfo.type;
                    valueManagedIns.value = constructorInfo.value;
                    definition.constructorArgs.push(valueManagedIns);
                }
            }
        }
        // inject properties
        for (const propertyMeta of definitionMeta.properties) {
            const refManaged = new managed_1.ManagedReference();
            refManaged.args = propertyMeta.args;
            if (this.midwayIdentifiers.includes(propertyMeta.value)) {
                refManaged.name = propertyMeta.value;
            }
            else {
                refManaged.name = (0, decorator_1.generateProvideId)(propertyMeta.value, definition.namespace);
            }
            definition.properties.set(propertyMeta.metaKey, refManaged);
        }
        definition.asynchronous = definitionMeta.asynchronous;
        definition.initMethod = definitionMeta.initMethod;
        definition.destroyMethod = definitionMeta.destroyMethod;
        definition.scope = definitionMeta.scope;
        definition.autowire = definitionMeta.autowire;
        definition.handlerProps = definitionMeta.handlerProps;
        this.registerDefinition(definitionMeta.id, definition);
        // 用 uuid 多保存一个副本
        const uuid = (0, decorator_1.getProviderUUId)(definitionMeta.path);
        if (uuid) {
            this.registerDefinition((0, decorator_1.getProviderUUId)(definitionMeta.path), definition);
        }
    }
    restoreDefinitions(definitionMetadataList) {
        if (definitionMetadataList && definitionMetadataList.length) {
            for (const definitionMeta of definitionMetadataList) {
                this.restoreDefinition(definitionMeta);
            }
        }
    }
    getDefinitionMetaList() {
        return this.definitionMetadataList;
    }
    bindModule(module, namespace = '', filePath) {
        if ((0, decorator_1.isClass)(module)) {
            const providerId = (0, decorator_1.isProvide)(module) ? (0, decorator_1.getProviderId)(module) : null;
            if (providerId) {
                if (namespace) {
                    (0, decorator_1.saveClassMetadata)(decorator_1.PRIVATE_META_DATA_KEY, { namespace, providerId, srcPath: filePath }, module);
                }
                this.bind((0, decorator_1.generateProvideId)(providerId, namespace), module, {
                    namespace,
                    srcPath: filePath,
                });
            }
            else {
                // no provide or js class must be skip
            }
        }
        else {
            const info = module[constants_1.FUNCTION_INJECT_KEY];
            if (info && info.id) {
                if (!info.scope) {
                    info.scope = decorator_1.ScopeEnum.Request;
                }
                this.bind((0, decorator_1.generateProvideId)(info.id, namespace), module, {
                    scope: info.scope,
                    isAutowire: info.isAutowire,
                    namespace,
                    srcPath: filePath,
                });
            }
        }
    }
    createChild(baseDir) {
        return new MidwayContainer(baseDir || this.baseDir, this);
    }
    registerDataHandler(handlerType, handler) {
        this.resolverHandler.registerHandler(handlerType, handler);
    }
    registerCustomBinding(objectDefinition, target) {
        // @async, @init, @destroy @scope
        const objDefOptions = (0, decorator_1.getObjectDefProps)(target);
        this.convertOptionsToDefinition(objDefOptions, objectDefinition);
        if (objectDefinition && !objectDefinition.scope) {
            this.debugLogger('  @scope => request');
            objectDefinition.scope = decorator_1.ScopeEnum.Request;
        }
    }
    registerObject(identifier, target) {
        this.midwayIdentifiers.push(identifier);
        if (this === null || this === void 0 ? void 0 : this.getCurrentNamespace()) {
            if ((this === null || this === void 0 ? void 0 : this.getCurrentNamespace()) === decorator_1.MAIN_MODULE_KEY) {
                // 如果是 main，则同步 alias 到所有的 namespace
                for (const value of this.configurationMap.values()) {
                    if (value.namespace !== decorator_1.MAIN_MODULE_KEY) {
                        const key = identifier.indexOf(value.namespace + ':') > -1
                            ? identifier
                            : value.namespace + ':' + identifier;
                        super.registerObject(key, target);
                    }
                }
            }
            else {
                const key = identifier.indexOf(this.getCurrentNamespace() + ':') > -1
                    ? identifier
                    : this.getCurrentNamespace() + ':' + identifier;
                identifier = key;
            }
        }
        return super.registerObject(identifier, target);
    }
    createConfiguration() {
        return new configuration_1.ContainerConfiguration(this);
    }
    addConfiguration(configuration) {
        if (configuration.namespace === '') {
            this.likeMainConfiguration.push(configuration);
        }
        else {
            this.configurationMap.set(configuration.packageName, configuration);
        }
    }
    containsConfiguration(namespace) {
        return this.configurationMap.has(namespace);
    }
    getConfigService() {
        return this.configService;
    }
    getEnvironmentService() {
        return this.environmentService;
    }
    getInformationService() {
        return this.informationService;
    }
    setInformationService(informationService) {
        this.informationService = informationService;
    }
    getAspectService() {
        return this.aspectService;
    }
    getCurrentEnv() {
        return this.environmentService.getCurrentEnvironment();
    }
    getCurrentNamespace() {
        return '';
    }
    resolve(target) {
        const tempContainer = new MidwayContainer();
        tempContainer.bind(target);
        tempContainer.parent = this;
        return tempContainer.get(target);
    }
    get(identifier, args) {
        if (typeof identifier !== 'string') {
            identifier = this.getIdentifier(identifier);
        }
        const ins = super.get(identifier, args);
        return this.aspectService.wrapperAspectToInstance(ins);
    }
    async getAsync(identifier, args) {
        if (typeof identifier !== 'string') {
            identifier = this.getIdentifier(identifier);
        }
        const ins = await super.getAsync(identifier, args);
        return this.aspectService.wrapperAspectToInstance(ins);
    }
    getIdentifier(target) {
        return (0, decorator_1.getProviderId)(target);
    }
    async ready() {
        if (this.readied)
            return;
        await super.ready();
        // 加载配置
        await this.configService.load();
    }
    async stop() {
        await super.stop();
    }
    /**
     * 注册 importObjects
     * @param objs configuration 中的 importObjects
     * @param namespace namespace
     */
    registerImportObjects(objs, namespace) {
        if (objs) {
            const keys = Object.keys(objs);
            for (const key of keys) {
                if (typeof objs[key] !== undefined) {
                    this.registerObject((0, decorator_1.generateProvideId)(key, namespace), objs[key]);
                }
            }
        }
    }
    /**
     * 初始化默认需要 bind 到 container 中的基础依赖
     */
    loadDefinitions() {
        // 默认加载 pipeline
        this.bindModule(pipeline_1.pipelineFactory);
    }
    loadConfiguration(opts, containerConfiguration) {
        const subDirs = containerConfiguration.getImportDirectory();
        if (subDirs && subDirs.length > 0) {
            this.debugLogger('load configuration dir => %j, namespace => %s.', subDirs, containerConfiguration.namespace);
            this.loadDirectory({
                ...opts,
                loadDir: subDirs,
                namespace: containerConfiguration.namespace,
            });
        }
        this.registerImportObjects(containerConfiguration.getImportObjects(), containerConfiguration.namespace);
    }
    convertOptionsToDefinition(options, definition) {
        if (options) {
            if (options.isAsync) {
                this.debugLogger('  register isAsync = true');
                definition.asynchronous = true;
            }
            if (options.initMethod) {
                this.debugLogger(`  register initMethod = ${options.initMethod}`);
                definition.initMethod = options.initMethod;
            }
            if (options.destroyMethod) {
                this.debugLogger(`  register destroyMethod = ${options.destroyMethod}`);
                definition.destroyMethod = options.destroyMethod;
            }
            if (options.scope) {
                this.debugLogger(`  register scope = ${options.scope}`);
                definition.scope = options.scope;
            }
            if (options.constructorArgs) {
                this.debugLogger(`  register constructorArgs = ${options.constructorArgs}`);
                definition.constructorArgs = options.constructorArgs;
            }
            if (options.isAutowire === false) {
                this.debugLogger(`  register autowire = ${options.isAutowire}`);
                definition.autowire = false;
            }
            else if (options.isAutowire === true) {
                this.debugLogger(`  register autowire = ${options.isAutowire}`);
                definition.autowire = true;
            }
        }
    }
    getResolverHandler() {
        return this.resolverHandler;
    }
    addDirectoryFilter(directoryFilter) {
        this.directoryFilterArray =
            this.directoryFilterArray.concat(directoryFilter);
    }
    setAttr(key, value) {
        this.attrMap.set(key, value);
    }
    getAttr(key) {
        return this.attrMap.get(key);
    }
}
exports.MidwayContainer = MidwayContainer;
//# sourceMappingURL=midwayContainer.js.map