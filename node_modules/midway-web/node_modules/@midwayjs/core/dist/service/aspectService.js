"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MidwayAspectService = void 0;
const decorator_1 = require("@midwayjs/decorator");
const pm = require("picomatch");
const util = require("util");
const debugLogger = util.debuglog('midway:container:aspect');
class MidwayAspectService {
    constructor(container) {
        this.container = container;
        this.aspectMappingMap = new WeakMap();
        this.aspectModuleSet = new Set();
    }
    /**
     * load aspect method for container
     * @private
     */
    async loadAspect() {
        // for aop implementation
        const aspectModules = (0, decorator_1.listModule)(decorator_1.ASPECT_KEY);
        // sort for aspect target
        let aspectDataList = [];
        for (const module of aspectModules) {
            const data = (0, decorator_1.getClassMetadata)(decorator_1.ASPECT_KEY, module);
            aspectDataList = aspectDataList.concat(data.map(el => {
                el.aspectModule = module;
                return el;
            }));
        }
        // sort priority
        aspectDataList.sort((pre, next) => {
            return (next.priority || 0) - (pre.priority || 0);
        });
        for (const aspectData of aspectDataList) {
            const aspectIns = await this.container.getAsync(aspectData.aspectModule);
            await this.addAspect(aspectIns, aspectData);
        }
        // 合并拦截器方法，提升性能
        for (const module of this.aspectModuleSet) {
            const aspectMapping = this.aspectMappingMap.get(module);
            for (const [method, aspectFn] of aspectMapping) {
                const composeFn = (ins, originMethod) => {
                    for (const fn of aspectFn) {
                        originMethod = fn(ins, originMethod);
                    }
                    return originMethod;
                };
                aspectMapping.set(method, [composeFn]);
            }
        }
        // 绑定完后清理 Set 记录
        this.aspectModuleSet.clear();
    }
    async addAspect(aspectIns, aspectData) {
        const module = aspectData.aspectTarget;
        const names = Object.getOwnPropertyNames(module.prototype);
        const isMatch = aspectData.match ? pm(aspectData.match) : () => true;
        // 存到 set 里用来做循环
        this.aspectModuleSet.add(module);
        /**
         * 拦截器流程
         * 1、在每个被拦截的 class 上做拦截标记，记录哪些方法需要被拦截
         * 2、Container 保存每个 class 的方法对应的拦截器数组
         * 3、创建完实例后，在返回前执行包裹逻辑，把需要拦截的方法都执行一遍拦截（不对原型做修改）
         */
        for (const name of names) {
            if (name === 'constructor' || !isMatch(name)) {
                continue;
            }
            const descriptor = Object.getOwnPropertyDescriptor(module.prototype, name);
            if (!descriptor || descriptor.writable === false) {
                continue;
            }
            // 把拦截器和当前容器绑定
            if (!this.aspectMappingMap.has(module)) {
                this.aspectMappingMap.set(module, new Map());
            }
            const mappingMap = this.aspectMappingMap.get(module);
            if (!mappingMap.has(name)) {
                mappingMap.set(name, []);
            }
            // 把拦截器本身加到数组中
            const methodAspectCollection = mappingMap.get(name);
            if ((0, decorator_1.isAsyncFunction)(descriptor.value)) {
                debugLogger(`aspect [#${module.name}:${name}], isAsync=true, aspect class=[${aspectIns.constructor.name}]`);
                const fn = (ins, originMethod) => {
                    return async (...args) => {
                        var _a, _b, _c;
                        let error, result;
                        const newProceed = (...args) => {
                            return originMethod.apply(ins, args);
                        };
                        const joinPoint = {
                            methodName: name,
                            target: ins,
                            args: args,
                            proceed: newProceed,
                        };
                        try {
                            await ((_a = aspectIns.before) === null || _a === void 0 ? void 0 : _a.call(aspectIns, joinPoint));
                            if (aspectIns.around) {
                                result = await aspectIns.around(joinPoint);
                            }
                            else {
                                result = await originMethod.apply(ins, joinPoint.args);
                            }
                            joinPoint.proceed = undefined;
                            const resultTemp = await ((_b = aspectIns.afterReturn) === null || _b === void 0 ? void 0 : _b.call(aspectIns, joinPoint, result));
                            result = typeof resultTemp === 'undefined' ? result : resultTemp;
                            return result;
                        }
                        catch (err) {
                            joinPoint.proceed = undefined;
                            error = err;
                            if (aspectIns.afterThrow) {
                                await aspectIns.afterThrow(joinPoint, error);
                            }
                            else {
                                throw err;
                            }
                        }
                        finally {
                            await ((_c = aspectIns.after) === null || _c === void 0 ? void 0 : _c.call(aspectIns, joinPoint, result, error));
                        }
                    };
                };
                methodAspectCollection.push(fn);
            }
            else {
                debugLogger(`aspect [#${module.name}:${name}], isAsync=false, aspect class=[${aspectIns.constructor.name}]`);
                const fn = (ins, originMethod) => {
                    return (...args) => {
                        var _a, _b, _c;
                        let error, result;
                        const newProceed = (...args) => {
                            return originMethod.apply(ins, args);
                        };
                        const joinPoint = {
                            methodName: name,
                            target: ins,
                            args: args,
                            proceed: newProceed,
                        };
                        try {
                            (_a = aspectIns.before) === null || _a === void 0 ? void 0 : _a.call(aspectIns, joinPoint);
                            if (aspectIns.around) {
                                result = aspectIns.around(joinPoint);
                            }
                            else {
                                result = originMethod.apply(ins, joinPoint.args);
                            }
                            const resultTemp = (_b = aspectIns.afterReturn) === null || _b === void 0 ? void 0 : _b.call(aspectIns, joinPoint, result);
                            result = typeof resultTemp === 'undefined' ? result : resultTemp;
                            if (result && (0, decorator_1.isClass)(result.constructor)) {
                                return this.wrapperAspectToInstance(ins);
                            }
                            else {
                                return result;
                            }
                        }
                        catch (err) {
                            error = err;
                            if (aspectIns.afterThrow) {
                                aspectIns.afterThrow(joinPoint, error);
                            }
                            else {
                                throw err;
                            }
                        }
                        finally {
                            (_c = aspectIns.after) === null || _c === void 0 ? void 0 : _c.call(aspectIns, joinPoint, result, error);
                        }
                    };
                };
                methodAspectCollection.push(fn);
            }
        }
    }
    /**
     * wrapper aspect method before instance return
     * @param ins
     * @protected
     */
    wrapperAspectToInstance(ins) {
        var _a, _b, _c, _d, _e;
        let proxy = null;
        /**
         * 过滤循环依赖创建的对象
         */
        if (!(0, decorator_1.isProxy)(ins) && (ins === null || ins === void 0 ? void 0 : ins.constructor)) {
            // 动态处理拦截器
            let methodAspectCollection;
            if ((_a = this.aspectMappingMap) === null || _a === void 0 ? void 0 : _a.has(ins.constructor)) {
                methodAspectCollection = this.aspectMappingMap.get(ins.constructor);
            }
            else if ((_c = (_b = this.container) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.getAspectService().hasAspect(ins.constructor)) {
                // for requestContainer
                methodAspectCollection = (_e = (_d = this.container) === null || _d === void 0 ? void 0 : _d.parent) === null || _e === void 0 ? void 0 : _e.getAspectService().hasAspect(ins.constructor);
            }
            if (methodAspectCollection) {
                proxy = new Proxy(ins, {
                    get: (obj, prop) => {
                        if (typeof prop === 'string' && methodAspectCollection.has(prop)) {
                            const aspectFn = methodAspectCollection.get(prop);
                            return aspectFn[0](ins, obj[prop]);
                        }
                        return obj[prop];
                    },
                });
            }
        }
        return proxy || ins;
    }
    hasAspect(module) {
        return this.aspectMappingMap.has(module);
    }
}
exports.MidwayAspectService = MidwayAspectService;
//# sourceMappingURL=aspectService.js.map