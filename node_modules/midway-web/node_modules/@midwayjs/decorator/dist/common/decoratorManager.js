"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProviderUUId = exports.isProvide = exports.saveProviderId = exports.getObjectDefProps = exports.saveObjectDefProps = exports.getPropertyInject = exports.savePropertyInject = exports.getConstructorInject = exports.saveConstructorInject = exports.attachConstructorDataOnClass = exports.getMethodReturnTypes = exports.getPropertyType = exports.getMethodParamTypes = exports.getObjectDefinition = exports.generateProvideId = exports.getProviderId = exports.clearAllModule = exports.resetModule = exports.listModule = exports.saveModule = exports.listPreloadModule = exports.savePreloadModule = exports.getPropertyMetadata = exports.attachPropertyMetadata = exports.savePropertyMetadata = exports.listPropertyDataFromClass = exports.getPropertyDataFromClass = exports.attachPropertyDataToClass = exports.savePropertyDataToClass = exports.getMethodMetadata = exports.attachMethodMetadata = exports.saveMethodMetadata = exports.listMethodDataFromClass = exports.getMethodDataFromClass = exports.attachMethodDataToClass = exports.saveMethodDataToClass = exports.throwErrorForTest = exports.getClassMetadata = exports.getClassExtendedMetadata = exports.attachClassMetadata = exports.saveClassMetadata = exports.DecoratorManager = exports.INJECT_CLASS_KEY_PREFIX = exports.PRELOAD_MODULE_KEY = void 0;
require("reflect-metadata");
const constant_1 = require("../constant");
const errMsg_1 = require("./errMsg");
const metadata_1 = require("./metadata");
const util_1 = require("../util");
const debug = require('util').debuglog('decorator:manager');
exports.PRELOAD_MODULE_KEY = 'INJECTION_PRELOAD_MODULE_KEY';
exports.INJECT_CLASS_KEY_PREFIX = 'INJECTION_CLASS_META_DATA';
class DecoratorManager extends Map {
    constructor() {
        super(...arguments);
        /**
         * the key for meta data store in class
         */
        this.injectClassKeyPrefix = exports.INJECT_CLASS_KEY_PREFIX;
        /**
         * the key for method meta data store in class
         */
        this.injectClassMethodKeyPrefix = 'INJECTION_CLASS_METHOD_META_DATA';
        /**
         * the key for method meta data store in method
         */
        this.injectMethodKeyPrefix = 'INJECTION_METHOD_META_DATA';
    }
    saveModule(key, module) {
        if (!this.has(key)) {
            this.set(key, new Set());
        }
        this.get(key).add(module);
    }
    resetModule(key) {
        this.set(key, new Set());
    }
    static getDecoratorClassKey(decoratorNameKey) {
        return decoratorNameKey.toString() + '_CLS';
    }
    static removeDecoratorClassKeySuffix(decoratorNameKey) {
        return decoratorNameKey.toString().replace('_CLS', '');
    }
    static getDecoratorMethodKey(decoratorNameKey) {
        return decoratorNameKey.toString() + '_METHOD';
    }
    static getDecoratorClsExtendedKey(decoratorNameKey) {
        return decoratorNameKey.toString() + '_EXT';
    }
    static getDecoratorClsMethodPrefix(decoratorNameKey) {
        return decoratorNameKey.toString() + '_CLS_METHOD';
    }
    static getDecoratorClsMethodKey(decoratorNameKey, methodKey) {
        return (DecoratorManager.getDecoratorClsMethodPrefix(decoratorNameKey) +
            ':' +
            methodKey.toString());
    }
    static getDecoratorMethod(decoratorNameKey, methodKey) {
        return (DecoratorManager.getDecoratorMethodKey(decoratorNameKey) +
            '_' +
            methodKey.toString());
    }
    listModule(key) {
        return Array.from(this.get(key) || {});
    }
    static saveMetadata(metaKey, target, dataKey, data) {
        debug('saveMetadata %s on target %o with dataKey = %s.', metaKey, target, dataKey);
        // filter Object.create(null)
        if (typeof target === 'object' && target.constructor) {
            target = target.constructor;
        }
        let m;
        if (Reflect.hasOwnMetadata(metaKey, target)) {
            m = Reflect.getMetadata(metaKey, target);
        }
        else {
            m = new Map();
        }
        m.set(dataKey, data);
        Reflect.defineMetadata(metaKey, m, target);
    }
    static attachMetadata(metaKey, target, dataKey, data, groupBy) {
        debug('attachMetadata %s on target %o with dataKey = %s.', metaKey, target, dataKey);
        // filter Object.create(null)
        if (typeof target === 'object' && target.constructor) {
            target = target.constructor;
        }
        let m;
        if (Reflect.hasOwnMetadata(metaKey, target)) {
            m = Reflect.getMetadata(metaKey, target);
        }
        else {
            m = new Map();
        }
        if (!m.has(dataKey)) {
            if (groupBy) {
                m.set(dataKey, {});
            }
            else {
                m.set(dataKey, []);
            }
        }
        if (groupBy) {
            m.get(dataKey)[groupBy] = data;
        }
        else {
            m.get(dataKey).push(data);
        }
        Reflect.defineMetadata(metaKey, m, target);
    }
    static getMetadata(metaKey, target, dataKey) {
        debug('getMetadata %s on target %o with dataKey = %s.', metaKey, target, dataKey);
        // filter Object.create(null)
        if (typeof target === 'object' && target.constructor) {
            target = target.constructor;
        }
        let m;
        if (!Reflect.hasOwnMetadata(metaKey, target)) {
            m = new Map();
            Reflect.defineMetadata(metaKey, m, target);
        }
        else {
            m = Reflect.getMetadata(metaKey, target);
        }
        if (!dataKey) {
            return m;
        }
        return m.get(dataKey);
    }
    /**
     * save meta data to class or property
     * @param decoratorNameKey the alias name for decorator
     * @param data the data you want to store
     * @param target target class
     * @param propertyName
     */
    saveMetadata(decoratorNameKey, data, target, propertyName) {
        if (propertyName) {
            const dataKey = DecoratorManager.getDecoratorMethod(decoratorNameKey, propertyName);
            DecoratorManager.saveMetadata(this.injectMethodKeyPrefix, target, dataKey, data);
        }
        else {
            const dataKey = DecoratorManager.getDecoratorClassKey(decoratorNameKey);
            DecoratorManager.saveMetadata(this.injectClassKeyPrefix, target, dataKey, data);
        }
    }
    /**
     * attach data to class or property
     * @param decoratorNameKey
     * @param data
     * @param target
     * @param propertyName
     */
    attachMetadata(decoratorNameKey, data, target, propertyName, groupBy) {
        if (propertyName) {
            const dataKey = DecoratorManager.getDecoratorMethod(decoratorNameKey, propertyName);
            DecoratorManager.attachMetadata(this.injectMethodKeyPrefix, target, dataKey, data, groupBy);
        }
        else {
            const dataKey = DecoratorManager.getDecoratorClassKey(decoratorNameKey);
            DecoratorManager.attachMetadata(this.injectClassKeyPrefix, target, dataKey, data, groupBy);
        }
    }
    /**
     * get single data from class or property
     * @param decoratorNameKey
     * @param target
     * @param propertyName
     */
    getMetadata(decoratorNameKey, target, propertyName) {
        if (propertyName) {
            const dataKey = DecoratorManager.getDecoratorMethod(decoratorNameKey, propertyName);
            return DecoratorManager.getMetadata(this.injectMethodKeyPrefix, target, dataKey);
        }
        else {
            const dataKey = `${DecoratorManager.getDecoratorClassKey(decoratorNameKey)}`;
            return DecoratorManager.getMetadata(this.injectClassKeyPrefix, target, dataKey);
        }
    }
    /**
     * save property data to class
     * @param decoratorNameKey
     * @param data
     * @param target
     * @param propertyName
     */
    savePropertyDataToClass(decoratorNameKey, data, target, propertyName) {
        const dataKey = DecoratorManager.getDecoratorClsMethodKey(decoratorNameKey, propertyName);
        DecoratorManager.saveMetadata(this.injectClassMethodKeyPrefix, target, dataKey, data);
    }
    /**
     * attach property data to class
     * @param decoratorNameKey
     * @param data
     * @param target
     * @param propertyName
     * @param groupBy
     */
    attachPropertyDataToClass(decoratorNameKey, data, target, propertyName, groupBy) {
        const dataKey = DecoratorManager.getDecoratorClsMethodKey(decoratorNameKey, propertyName);
        DecoratorManager.attachMetadata(this.injectClassMethodKeyPrefix, target, dataKey, data, groupBy);
    }
    /**
     * get property data from class
     * @param decoratorNameKey
     * @param target
     * @param propertyName
     */
    getPropertyDataFromClass(decoratorNameKey, target, propertyName) {
        const dataKey = DecoratorManager.getDecoratorClsMethodKey(decoratorNameKey, propertyName);
        return DecoratorManager.getMetadata(this.injectClassMethodKeyPrefix, target, dataKey);
    }
    /**
     * list property data from class
     * @param decoratorNameKey
     * @param target
     */
    listPropertyDataFromClass(decoratorNameKey, target) {
        const originMap = DecoratorManager.getMetadata(this.injectClassMethodKeyPrefix, target);
        const res = [];
        for (const [key, value] of originMap) {
            if (key.indexOf(DecoratorManager.getDecoratorClsMethodPrefix(decoratorNameKey)) !== -1) {
                res.push(value);
            }
        }
        return res;
    }
}
exports.DecoratorManager = DecoratorManager;
let manager = new DecoratorManager();
if (global['MIDWAY_GLOBAL_DECORATOR_MANAGER']) {
    console.warn('DecoratorManager not singleton and please check @midwayjs/decorator version by "npm ls @midwayjs/decorator"');
    manager = global['MIDWAY_GLOBAL_DECORATOR_MANAGER'];
}
else {
    global['MIDWAY_GLOBAL_DECORATOR_MANAGER'] = manager;
}
/**
 * save data to class
 * @param decoratorNameKey
 * @param data
 * @param target
 */
function saveClassMetadata(decoratorNameKey, data, target) {
    return manager.saveMetadata(decoratorNameKey, data, target);
}
exports.saveClassMetadata = saveClassMetadata;
/**
 * attach data to class
 * @param decoratorNameKey
 * @param data
 * @param target
 * @param groupBy
 */
function attachClassMetadata(decoratorNameKey, data, target, groupBy) {
    return manager.attachMetadata(decoratorNameKey, data, target, undefined, groupBy);
}
exports.attachClassMetadata = attachClassMetadata;
const testKeyMap = new Map();
/**
 * get data from class assign
 * @param decoratorNameKey
 * @param target
 */
function getClassExtendedMetadata(decoratorNameKey, target) {
    const extKey = DecoratorManager.getDecoratorClsExtendedKey(decoratorNameKey);
    let metadata = manager.getMetadata(extKey, target);
    if (metadata !== undefined) {
        return metadata;
    }
    const father = Reflect.getPrototypeOf(target);
    if (father.constructor !== Object) {
        metadata = mergeMeta(getClassExtendedMetadata(decoratorNameKey, father), manager.getMetadata(decoratorNameKey, target));
    }
    manager.saveMetadata(extKey, metadata || null, target);
    return metadata;
}
exports.getClassExtendedMetadata = getClassExtendedMetadata;
function mergeMeta(target, src) {
    if (!target) {
        target = src;
        src = null;
    }
    if (!target) {
        return null;
    }
    if (Array.isArray(target)) {
        return target.concat(src || []);
    }
    if (typeof target === 'object') {
        return Object.assign({}, target, src);
    }
    throw new Error('can not merge meta that type of ' + typeof target);
}
/**
 * get data from class
 * @param decoratorNameKey
 * @param target
 */
function getClassMetadata(decoratorNameKey, target) {
    if (testKeyMap.size > 0 && testKeyMap.has(decoratorNameKey)) {
        throw testKeyMap.get(decoratorNameKey);
    }
    return manager.getMetadata(decoratorNameKey, target);
}
exports.getClassMetadata = getClassMetadata;
// TODO 因 https://github.com/microsoft/TypeScript/issues/38820 等 4.0 发布移除掉
function throwErrorForTest(key, e) {
    if (e) {
        testKeyMap.set(key, e);
    }
    else {
        testKeyMap.delete(key);
    }
}
exports.throwErrorForTest = throwErrorForTest;
/**
 * this method has deprecated and use savePropertyDataToClass instead
 *
 * @deprecated
 * @param decoratorNameKey
 * @param data
 * @param target
 * @param method
 */
function saveMethodDataToClass(decoratorNameKey, data, target, method) {
    return manager.savePropertyDataToClass(decoratorNameKey, data, target, method);
}
exports.saveMethodDataToClass = saveMethodDataToClass;
/**
 * this method has deprecated and use attachPropertyDataToClass instead
 *
 * @deprecated
 * @param decoratorNameKey
 * @param data
 * @param target
 * @param method
 */
function attachMethodDataToClass(decoratorNameKey, data, target, method) {
    return manager.attachPropertyDataToClass(decoratorNameKey, data, target, method);
}
exports.attachMethodDataToClass = attachMethodDataToClass;
/**
 * this method has deprecated and use getPropertyDataFromClass instead
 *
 * @deprecated
 * @param decoratorNameKey
 * @param target
 * @param method
 */
function getMethodDataFromClass(decoratorNameKey, target, method) {
    return manager.getPropertyDataFromClass(decoratorNameKey, target, method);
}
exports.getMethodDataFromClass = getMethodDataFromClass;
/**
 * list method data from class
 * @deprecated
 * @param decoratorNameKey
 * @param target
 */
function listMethodDataFromClass(decoratorNameKey, target) {
    return manager.listPropertyDataFromClass(decoratorNameKey, target);
}
exports.listMethodDataFromClass = listMethodDataFromClass;
/**
 * save method data
 * @deprecated
 * @param decoratorNameKey
 * @param data
 * @param target
 * @param method
 */
function saveMethodMetadata(decoratorNameKey, data, target, method) {
    return manager.saveMetadata(decoratorNameKey, data, target, method);
}
exports.saveMethodMetadata = saveMethodMetadata;
/**
 * attach method data
 * @deprecated
 * @param decoratorNameKey
 * @param data
 * @param target
 * @param method
 */
function attachMethodMetadata(decoratorNameKey, data, target, method) {
    return manager.attachMetadata(decoratorNameKey, data, target, method);
}
exports.attachMethodMetadata = attachMethodMetadata;
/**
 * get method data
 * @deprecated
 * @param decoratorNameKey
 * @param target
 * @param method
 */
function getMethodMetadata(decoratorNameKey, target, method) {
    return manager.getMetadata(decoratorNameKey, target, method);
}
exports.getMethodMetadata = getMethodMetadata;
/**
 * save property data to class
 * @param decoratorNameKey
 * @param data
 * @param target
 * @param propertyName
 */
function savePropertyDataToClass(decoratorNameKey, data, target, propertyName) {
    return manager.savePropertyDataToClass(decoratorNameKey, data, target, propertyName);
}
exports.savePropertyDataToClass = savePropertyDataToClass;
/**
 * attach property data to class
 * @param decoratorNameKey
 * @param data
 * @param target
 * @param propertyName
 * @param groupBy
 */
function attachPropertyDataToClass(decoratorNameKey, data, target, propertyName, groupBy) {
    return manager.attachPropertyDataToClass(decoratorNameKey, data, target, propertyName, groupBy);
}
exports.attachPropertyDataToClass = attachPropertyDataToClass;
/**
 * get property data from class
 * @param decoratorNameKey
 * @param target
 * @param propertyName
 */
function getPropertyDataFromClass(decoratorNameKey, target, propertyName) {
    return manager.getPropertyDataFromClass(decoratorNameKey, target, propertyName);
}
exports.getPropertyDataFromClass = getPropertyDataFromClass;
/**
 * list property data from class
 * @param decoratorNameKey
 * @param target
 */
function listPropertyDataFromClass(decoratorNameKey, target) {
    return manager.listPropertyDataFromClass(decoratorNameKey, target);
}
exports.listPropertyDataFromClass = listPropertyDataFromClass;
/**
 * save property data
 * @param decoratorNameKey
 * @param data
 * @param target
 * @param propertyName
 */
function savePropertyMetadata(decoratorNameKey, data, target, propertyName) {
    return manager.saveMetadata(decoratorNameKey, data, target, propertyName);
}
exports.savePropertyMetadata = savePropertyMetadata;
/**
 * attach property data
 * @param decoratorNameKey
 * @param data
 * @param target
 * @param propertyName
 */
function attachPropertyMetadata(decoratorNameKey, data, target, propertyName) {
    return manager.attachMetadata(decoratorNameKey, data, target, propertyName);
}
exports.attachPropertyMetadata = attachPropertyMetadata;
/**
 * get property data
 * @param decoratorNameKey
 * @param target
 * @param propertyName
 */
function getPropertyMetadata(decoratorNameKey, target, propertyName) {
    return manager.getMetadata(decoratorNameKey, target, propertyName);
}
exports.getPropertyMetadata = getPropertyMetadata;
/**
 * save preload module by target
 * @param target
 */
function savePreloadModule(target) {
    return saveModule(exports.PRELOAD_MODULE_KEY, target);
}
exports.savePreloadModule = savePreloadModule;
/**
 * list preload module
 */
function listPreloadModule() {
    return listModule(exports.PRELOAD_MODULE_KEY);
}
exports.listPreloadModule = listPreloadModule;
/**
 * save module to inner map
 * @param decoratorNameKey
 * @param target
 */
function saveModule(decoratorNameKey, target) {
    return manager.saveModule(decoratorNameKey, target);
}
exports.saveModule = saveModule;
/**
 * list module from decorator key
 * @param decoratorNameKey
 */
function listModule(decoratorNameKey, filter) {
    const modules = manager.listModule(decoratorNameKey);
    if (filter) {
        return modules.filter(filter);
    }
    else {
        return modules;
    }
}
exports.listModule = listModule;
/**
 * reset module
 * @param decoratorNameKey
 */
function resetModule(decoratorNameKey) {
    return manager.resetModule(decoratorNameKey);
}
exports.resetModule = resetModule;
/**
 * clear all module
 */
function clearAllModule() {
    return manager.clear();
}
exports.clearAllModule = clearAllModule;
/**
 * get provider id from module
 * @param module
 */
function getProviderId(module) {
    const metaData = Reflect.getMetadata(constant_1.TAGGED_CLS, module);
    let providerId;
    if (metaData) {
        providerId = metaData.id;
    }
    else {
        providerId = (0, util_1.classNamed)(module.name);
    }
    const meta = getClassMetadata(constant_1.PRIVATE_META_DATA_KEY, module);
    if (providerId && meta) {
        providerId = generateProvideId(providerId, meta.namespace);
    }
    return providerId;
}
exports.getProviderId = getProviderId;
/**
 * 生成带 namespace 的 provideId
 * @param provideId provideId
 * @param namespace namespace
 */
function generateProvideId(provideId, namespace) {
    if (namespace && namespace !== constant_1.MAIN_MODULE_KEY) {
        if (provideId.includes('@')) {
            return provideId.substr(1);
        }
        if (provideId.includes(':')) {
            return provideId;
        }
        if (namespace.includes('@')) {
            namespace = namespace.substr(1);
        }
        return namespace + ':' + provideId;
    }
    return provideId;
}
exports.generateProvideId = generateProvideId;
/**
 * get object definition metadata
 * @param module
 */
function getObjectDefinition(module) {
    return Reflect.getMetadata(constant_1.OBJ_DEF_CLS, module);
}
exports.getObjectDefinition = getObjectDefinition;
function transformTypeFromTSDesign(designFn) {
    if ((0, util_1.isNullOrUndefined)(designFn)) {
        return { name: 'undefined', isBaseType: true, originDesign: designFn };
    }
    switch (designFn.name) {
        case 'String':
            return { name: 'string', isBaseType: true, originDesign: designFn };
        case 'Number':
            return { name: 'number', isBaseType: true, originDesign: designFn };
        case 'Boolean':
            return { name: 'boolean', isBaseType: true, originDesign: designFn };
        case 'Symbol':
            return { name: 'symbol', isBaseType: true, originDesign: designFn };
        case 'Object':
            return { name: 'object', isBaseType: true, originDesign: designFn };
        case 'Function':
            return { name: 'function', isBaseType: true, originDesign: designFn };
        default:
            return {
                name: designFn.name,
                isBaseType: false,
                originDesign: designFn,
            };
    }
}
/**
 * get parameters type by reflect-metadata
 */
function getMethodParamTypes(target, propertyKey) {
    return Reflect.getMetadata('design:paramtypes', target, propertyKey);
}
exports.getMethodParamTypes = getMethodParamTypes;
function getPropertyType(target, propertyKey) {
    return transformTypeFromTSDesign(Reflect.getMetadata('design:type', target, propertyKey));
}
exports.getPropertyType = getPropertyType;
function getMethodReturnTypes(target, propertyKey) {
    return Reflect.getMetadata('design:returntype', target, propertyKey);
}
exports.getMethodReturnTypes = getMethodReturnTypes;
function _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex) {
    let paramsOrPropertiesMetadata = {};
    const isParameterDecorator = typeof parameterIndex === 'number';
    const key = parameterIndex !== undefined && isParameterDecorator
        ? parameterIndex.toString()
        : propertyName;
    // if the decorator is used as a parameter decorator, the property name must be provided
    if (isParameterDecorator && propertyName !== undefined) {
        throw new Error(errMsg_1.INVALID_DECORATOR_OPERATION);
    }
    // read metadata if available
    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
    }
    // get metadata for the decorated parameter by its index
    let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
    if (!Array.isArray(paramOrPropertyMetadata)) {
        paramOrPropertyMetadata = [];
    }
    else {
        for (const m of paramOrPropertyMetadata) {
            if (m.key === metadata.key) {
                throw new Error(`${errMsg_1.DUPLICATED_METADATA} ${m.key.toString()}`);
            }
        }
    }
    // set metadata
    paramOrPropertyMetadata.push(metadata);
    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function attachConstructorDataOnClass(identifier, clz, type, index) {
    if (!identifier) {
        const args = (0, util_1.getParamNames)(clz);
        if (clz.length === args.length && index < clz.length) {
            identifier = args[index];
        }
    }
    // save constructor index on class
    let constructorMetaValue = getClassMetadata(constant_1.CLASS_KEY_CONSTRUCTOR, clz);
    if (!constructorMetaValue) {
        constructorMetaValue = {};
    }
    constructorMetaValue[index] = {
        key: identifier,
        type,
    };
    saveClassMetadata(constant_1.CLASS_KEY_CONSTRUCTOR, constructorMetaValue, clz);
}
exports.attachConstructorDataOnClass = attachConstructorDataOnClass;
/**
 * 构造器注入
 * @param opts 参数
 */
function saveConstructorInject(opts) {
    let identifier = opts.identifier;
    if (!identifier) {
        const args = (0, util_1.getParamNames)(opts.target);
        if (opts.target.length === args.length && opts.index < opts.target.length) {
            identifier = args[opts.index];
        }
    }
    else if (identifier.includes('@') && !identifier.includes(':')) {
        const args = (0, util_1.getParamNames)(opts.target);
        if (opts.target.length === args.length && opts.index < opts.target.length) {
            identifier = `${identifier}:${args[opts.index]}`;
        }
    }
    const metadata = new metadata_1.Metadata(constant_1.INJECT_TAG, identifier);
    metadata.args = opts.args;
    _tagParameterOrProperty(constant_1.TAGGED, opts.target, opts.targetKey, metadata, opts.index);
}
exports.saveConstructorInject = saveConstructorInject;
function getConstructorInject(target) {
    return Reflect.getMetadata(constant_1.TAGGED, target);
}
exports.getConstructorInject = getConstructorInject;
/**
 * 属性注入
 * @param opts 参数
 */
function savePropertyInject(opts) {
    var _a;
    let identifier = opts.identifier;
    if (!identifier) {
        const type = getPropertyType(opts.target, opts.targetKey);
        if (!type.isBaseType &&
            (0, util_1.isClass)(type.originDesign) &&
            isProvide(type.originDesign)) {
            identifier =
                (_a = getProviderUUId(type.originDesign)) !== null && _a !== void 0 ? _a : getProviderId(type.originDesign);
        }
        if (!identifier) {
            identifier = opts.targetKey;
        }
    }
    if (identifier.includes('@') && !identifier.includes(':')) {
        identifier = `${identifier}:${opts.targetKey}`;
    }
    const metadata = new metadata_1.Metadata(constant_1.INJECT_TAG, identifier);
    metadata.args = opts.args;
    _tagParameterOrProperty(constant_1.TAGGED_PROP, opts.target.constructor, opts.targetKey, metadata);
}
exports.savePropertyInject = savePropertyInject;
function getPropertyInject(target) {
    return Reflect.getMetadata(constant_1.TAGGED_PROP, target);
}
exports.getPropertyInject = getPropertyInject;
/**
 * class 元数据定义
 * @param target class
 * @param props 属性
 */
function saveObjectDefProps(target, props = {}) {
    if (Reflect.hasMetadata(constant_1.OBJ_DEF_CLS, target)) {
        const originProps = Reflect.getMetadata(constant_1.OBJ_DEF_CLS, target);
        Reflect.defineMetadata(constant_1.OBJ_DEF_CLS, Object.assign(originProps, props), target);
    }
    else {
        Reflect.defineMetadata(constant_1.OBJ_DEF_CLS, props, target);
    }
    return target;
}
exports.saveObjectDefProps = saveObjectDefProps;
function getObjectDefProps(target) {
    return Reflect.getMetadata(constant_1.OBJ_DEF_CLS, target);
}
exports.getObjectDefProps = getObjectDefProps;
/**
 * class provider id
 * @param identifier id
 * @param target class
 * @param override 是否覆盖
 */
function saveProviderId(identifier, target, override) {
    if (Reflect.hasOwnMetadata(constant_1.TAGGED_CLS, target) && !override) {
        throw new Error(errMsg_1.DUPLICATED_INJECTABLE_DECORATOR);
    }
    if (!identifier) {
        identifier = (0, util_1.classNamed)(target.name);
    }
    const uuid = (0, util_1.generateRandomId)();
    Reflect.defineMetadata(constant_1.TAGGED_CLS, {
        id: identifier,
        originName: target.name,
        uuid,
    }, target);
    if (!Reflect.hasMetadata(constant_1.OBJ_DEF_CLS, target)) {
        Reflect.defineMetadata(constant_1.OBJ_DEF_CLS, {}, target);
    }
    return target;
}
exports.saveProviderId = saveProviderId;
/**
 * 是否使用了 saveProviderId
 * @param target class
 */
function isProvide(target) {
    return Reflect.hasOwnMetadata(constant_1.TAGGED_CLS, target);
}
exports.isProvide = isProvide;
function getProviderUUId(module) {
    const metaData = Reflect.getMetadata(constant_1.TAGGED_CLS, module);
    if (metaData && metaData.uuid) {
        return metaData.uuid;
    }
}
exports.getProviderUUId = getProviderUUId;
//# sourceMappingURL=decoratorManager.js.map