"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRandomId = exports.classNamed = exports.getParamNames = exports.sleep = exports.isNullOrUndefined = exports.isNull = exports.isUndefined = exports.isRegExp = exports.isSet = exports.isMap = exports.isProxy = exports.isNumber = exports.isObject = exports.isFunction = exports.isPromise = exports.isGeneratorFunction = exports.isAsyncFunction = exports.isClass = void 0;
const util = require("util");
const camelcase = require("camelcase");
const crypto = require("crypto");
const ToString = Function.prototype.toString;
function fnBody(fn) {
    return ToString.call(fn)
        .replace(/^[^{]*{\s*/, '')
        .replace(/\s*}[^}]*$/, '');
}
function isClass(fn) {
    if (typeof fn !== 'function') {
        return false;
    }
    if (/^class[\s{]/.test(ToString.call(fn))) {
        return true;
    }
    // babel.js classCallCheck() & inlined
    const body = fnBody(fn);
    return (/classCallCheck\(/.test(body) ||
        /TypeError\("Cannot call a class as a function"\)/.test(body));
}
exports.isClass = isClass;
function isAsyncFunction(value) {
    return util.types.isAsyncFunction(value);
}
exports.isAsyncFunction = isAsyncFunction;
function isGeneratorFunction(value) {
    return util.types.isGeneratorFunction(value);
}
exports.isGeneratorFunction = isGeneratorFunction;
function isPromise(value) {
    return util.types.isPromise(value);
}
exports.isPromise = isPromise;
function isFunction(value) {
    return typeof value === 'function';
}
exports.isFunction = isFunction;
function isObject(value) {
    return value !== null && typeof value === 'object';
}
exports.isObject = isObject;
function isNumber(value) {
    return typeof value === 'number';
}
exports.isNumber = isNumber;
function isProxy(value) {
    return util.types.isProxy(value);
}
exports.isProxy = isProxy;
function isMap(value) {
    return util.types.isMap(value);
}
exports.isMap = isMap;
function isSet(value) {
    return util.types.isSet(value);
}
exports.isSet = isSet;
function isRegExp(value) {
    return util.types.isRegExp(value);
}
exports.isRegExp = isRegExp;
function isUndefined(value) {
    return value === undefined;
}
exports.isUndefined = isUndefined;
function isNull(value) {
    return value === null;
}
exports.isNull = isNull;
function isNullOrUndefined(value) {
    return isUndefined(value) || isNull(value);
}
exports.isNullOrUndefined = isNullOrUndefined;
function sleep(sleepTime = 1000) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, sleepTime);
    });
}
exports.sleep = sleep;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
/**
 * get parameter name from function
 * @param func
 */
function getParamNames(func) {
    const fnStr = func.toString().replace(STRIP_COMMENTS, '');
    let result = fnStr
        .slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')'))
        .split(',')
        .map(content => {
        return content.trim().replace(/\s?=.*$/, '');
    });
    if (result.length === 1 && result[0] === '') {
        result = [];
    }
    return result;
}
exports.getParamNames = getParamNames;
/**
 * 按照框架规则返回类名字
 * @param name 类名称
 */
function classNamed(name) {
    return camelcase(name);
}
exports.classNamed = classNamed;
/**
 * generate a lightweight random id, enough for ioc container
 */
function generateRandomId() {
    // => f9b327e70bbcf42494ccb28b2d98e00e
    return crypto.randomBytes(16).toString('hex');
}
exports.generateRandomId = generateRandomId;
//# sourceMappingURL=index.js.map