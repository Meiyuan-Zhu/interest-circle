"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.delegateTargetProperties = exports.delegateTargetMethod = exports.delegateTargetPrototypeMethod = exports.joinURLPath = exports.getUserHome = exports.parsePrefix = exports.safelyGet = exports.safeRequire = exports.getCurrentEnvironment = exports.isDevelopmentEnvironment = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const util_1 = require("util");
const debug = (0, util_1.debuglog)('midway:container:util');
const isDevelopmentEnvironment = env => {
    return ['local', 'test', 'unittest'].includes(env);
};
exports.isDevelopmentEnvironment = isDevelopmentEnvironment;
const getCurrentEnvironment = () => {
    return process.env['MIDWAY_SERVER_ENV'] || process.env['NODE_ENV'] || 'prod';
};
exports.getCurrentEnvironment = getCurrentEnvironment;
const safeRequire = (p, enabledCache = true) => {
    if (p.startsWith(`.${path_1.sep}`) || p.startsWith(`..${path_1.sep}`)) {
        p = (0, path_1.resolve)((0, path_1.dirname)(module.parent.filename), p);
    }
    try {
        if (enabledCache) {
            return require(p);
        }
        else {
            const content = (0, fs_1.readFileSync)(p, {
                encoding: 'utf-8',
            });
            return JSON.parse(content);
        }
    }
    catch (err) {
        debug('SafeRequire Warning', err.message);
        return undefined;
    }
};
exports.safeRequire = safeRequire;
/**
 *  safelyGet(['a','b'],{a: {b: 2}})  // => 2
 *  safelyGet(['a','b'],{c: {b: 2}})  // => undefined
 *  safelyGet(['a','1'],{a: {"1": 2}})  // => 2
 *  safelyGet(['a','1'],{a: {b: 2}})  // => undefined
 *  safelyGet('a.b',{a: {b: 2}})  // => 2
 *  safelyGet('a.b',{c: {b: 2}})  // => undefined
 */
function safelyGet(list, obj) {
    if (arguments.length === 1) {
        return (_obj) => safelyGet(list, _obj);
    }
    if (typeof obj === 'undefined' || typeof obj !== 'object' || obj === null) {
        return void 0;
    }
    const pathArrValue = typeof list === 'string' ? list.split('.') : list;
    let willReturn = obj;
    for (const key of pathArrValue) {
        if (typeof willReturn === 'undefined' || willReturn === null) {
            return void 0;
        }
        else if (typeof willReturn !== 'object') {
            return void 0;
        }
        willReturn = willReturn[key];
    }
    return willReturn;
}
exports.safelyGet = safelyGet;
/**
 * 剔除 @ 符号
 * @param provideId provideId
 */
function parsePrefix(provideId) {
    if (provideId.includes('@')) {
        return provideId.substr(1);
    }
    return provideId;
}
exports.parsePrefix = parsePrefix;
function getUserHome() {
    return process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];
}
exports.getUserHome = getUserHome;
function joinURLPath(...strArray) {
    if (strArray.length === 0) {
        return '';
    }
    let p = path_1.posix.join(...strArray);
    p = p.replace(/\/+$/, '');
    if (!/^\//.test(p)) {
        p = '/' + p;
    }
    return p;
}
exports.joinURLPath = joinURLPath;
/**
 * 代理目标所有的原型方法，不包括构造器和内部隐藏方法
 * @param derivedCtor
 * @param constructors
 */
function delegateTargetPrototypeMethod(derivedCtor, constructors) {
    constructors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            if (name !== 'constructor' && !/^_/.test(name)) {
                derivedCtor.prototype[name] = function (...args) {
                    return this.instance[name](...args);
                };
            }
        });
    });
}
exports.delegateTargetPrototypeMethod = delegateTargetPrototypeMethod;
/**
 * 代理目标原型上的特定方法
 * @param derivedCtor
 * @param methods
 */
function delegateTargetMethod(derivedCtor, methods) {
    methods.forEach(name => {
        derivedCtor.prototype[name] = function (...args) {
            return this.instance[name](...args);
        };
    });
}
exports.delegateTargetMethod = delegateTargetMethod;
/**
 * 代理目标原型属性
 * @param derivedCtor
 * @param properties
 */
function delegateTargetProperties(derivedCtor, properties) {
    properties.forEach(name => {
        Object.defineProperty(derivedCtor.prototype, name, {
            get() {
                return this.instance[name];
            },
        });
    });
}
exports.delegateTargetProperties = delegateTargetProperties;
//# sourceMappingURL=index.js.map