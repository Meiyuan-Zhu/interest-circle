"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebRouterCollector = void 0;
const emptyFramework_1 = require("./emptyFramework");
const decorator_1 = require("@midwayjs/decorator");
const midwayContainer_1 = require("../context/midwayContainer");
const index_1 = require("./index");
class WebRouterCollector {
    constructor(baseDir = '', options = {}) {
        this.isReady = false;
        this.routes = new Map();
        this.routesPriority = [];
        this.baseDir = baseDir;
        this.options = options;
    }
    async analyze() {
        if (!midwayContainer_1.MidwayContainer.parentDefinitionMetadata) {
            const framework = new emptyFramework_1.EmptyFramework();
            await framework.initialize({
                baseDir: this.baseDir,
            });
            this.applicationContext = framework.getApplicationContext();
        }
        else {
            this.applicationContext = midwayContainer_1.MidwayContainer.parentApplicationContext;
        }
        const controllerModules = (0, decorator_1.listModule)(decorator_1.CONTROLLER_KEY);
        for (const module of controllerModules) {
            this.collectRoute(module);
        }
        if (this.options.includeFunctionRouter) {
            const fnModules = (0, decorator_1.listModule)(decorator_1.FUNC_KEY);
            for (const module of fnModules) {
                this.collectFunctionRoute(module);
            }
        }
        // sort router
        for (const prefix of this.routes.keys()) {
            const routerInfo = this.routes.get(prefix);
            this.routes.set(prefix, this.sortRouter(routerInfo));
        }
        // sort prefix
        this.routesPriority = this.routesPriority.sort((routeA, routeB) => {
            return routeB.priority - routeA.priority;
        });
    }
    getApplicationContext() {
        return this.applicationContext;
    }
    collectRoute(module, functionMeta = false) {
        const controllerId = (0, decorator_1.getProviderId)(module);
        const controllerOption = (0, decorator_1.getClassMetadata)(decorator_1.CONTROLLER_KEY, module);
        // sort for priority
        let priority = (0, decorator_1.getClassMetadata)(decorator_1.PRIORITY_KEY, module);
        // implement middleware in controller
        const middleware = controllerOption.routerOptions.middleware;
        const prefix = controllerOption.prefix || '/';
        if (prefix === '/' && priority === undefined) {
            priority = -999;
        }
        if (!this.routes.has(prefix)) {
            this.routes.set(prefix, []);
            this.routesPriority.push({
                prefix,
                priority: priority || 0,
                middleware,
                routerOptions: controllerOption.routerOptions,
                controllerId,
            });
        }
        const webRouterInfo = (0, decorator_1.getClassMetadata)(decorator_1.WEB_ROUTER_KEY, module);
        if (webRouterInfo && typeof webRouterInfo[Symbol.iterator] === 'function') {
            for (const webRouter of webRouterInfo) {
                const routeArgsInfo = (0, decorator_1.getPropertyDataFromClass)(decorator_1.WEB_ROUTER_PARAM_KEY, module, webRouter.method) || [];
                const routerResponseData = (0, decorator_1.getPropertyMetadata)(decorator_1.WEB_RESPONSE_KEY, module, webRouter.method) || [];
                const data = {
                    prefix,
                    routerName: webRouter.routerName || '',
                    url: webRouter.path,
                    requestMethod: webRouter.requestMethod,
                    method: webRouter.method,
                    description: webRouter.description || '',
                    summary: webRouter.summary || '',
                    handlerName: `${controllerId}.${webRouter.method}`,
                    funcHandlerName: `${controllerId}.${webRouter.method}`,
                    controllerId,
                    middleware: webRouter.middleware || [],
                    controllerMiddleware: middleware || [],
                    requestMetadata: routeArgsInfo,
                    responseMetadata: routerResponseData,
                };
                if (functionMeta) {
                    // get function information
                    data.functionName = controllerId + '-' + webRouter.method;
                    data.functionTriggerName = decorator_1.ServerlessTriggerType.HTTP;
                    data.functionTriggerMetadata = {
                        path: (0, index_1.joinURLPath)(prefix, webRouter.path.toString()),
                        method: webRouter.requestMethod,
                    };
                    data.functionMetadata = {
                        functionName: data.functionName,
                    };
                }
                this.checkDuplicateAndPush(prefix, data);
            }
        }
    }
    collectFunctionRoute(module, functionMeta = false) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        // 老的函数路由
        const webRouterInfo = (0, decorator_1.getClassMetadata)(decorator_1.FUNC_KEY, module);
        const controllerId = (0, decorator_1.getProviderId)(module);
        const prefix = '/';
        if (!this.routes.has(prefix)) {
            this.routes.set(prefix, []);
            this.routesPriority.push({
                prefix,
                priority: -999,
                middleware: [],
                routerOptions: {},
                controllerId,
            });
        }
        for (const webRouter of webRouterInfo) {
            if (webRouter['type']) {
                // 新的 @ServerlessTrigger 写法
                if ((_a = webRouter['metadata']) === null || _a === void 0 ? void 0 : _a['path']) {
                    const routeArgsInfo = (0, decorator_1.getPropertyDataFromClass)(decorator_1.WEB_ROUTER_PARAM_KEY, module, webRouter['methodName']) || [];
                    const routerResponseData = (0, decorator_1.getPropertyMetadata)(decorator_1.WEB_RESPONSE_KEY, module, webRouter['methodName']) || [];
                    // 新 http/api gateway 函数
                    const data = {
                        prefix,
                        routerName: '',
                        url: webRouter['metadata']['path'],
                        requestMethod: (_c = (_b = webRouter['metadata']) === null || _b === void 0 ? void 0 : _b['method']) !== null && _c !== void 0 ? _c : 'get',
                        method: webRouter['methodName'],
                        description: '',
                        summary: '',
                        handlerName: `${controllerId}.${webRouter['methodName']}`,
                        funcHandlerName: `${controllerId}.${webRouter['methodName']}`,
                        controllerId,
                        middleware: ((_d = webRouter['metadata']) === null || _d === void 0 ? void 0 : _d['middleware']) || [],
                        controllerMiddleware: [],
                        requestMetadata: routeArgsInfo,
                        responseMetadata: routerResponseData,
                    };
                    if (functionMeta) {
                        data.functionName = webRouter['functionName'];
                        data.functionTriggerName = webRouter['type'];
                        data.functionTriggerMetadata = webRouter['metadata'];
                        const functionMeta = (0, decorator_1.getPropertyMetadata)(decorator_1.SERVERLESS_FUNC_KEY, module, webRouter['methodName']) || {};
                        data.functionMetadata = {
                            functionName: webRouter['functionName'],
                            ...functionMeta,
                        };
                    }
                    this.checkDuplicateAndPush(prefix, data);
                }
                else {
                    if (functionMeta) {
                        const functionMeta = (0, decorator_1.getPropertyMetadata)(decorator_1.SERVERLESS_FUNC_KEY, module, webRouter['methodName']) || {};
                        // 其他类型的函数
                        this.checkDuplicateAndPush(prefix, {
                            prefix,
                            routerName: '',
                            url: '',
                            requestMethod: '',
                            method: webRouter['methodName'],
                            description: '',
                            summary: '',
                            handlerName: `${controllerId}.${webRouter['methodName']}`,
                            funcHandlerName: `${controllerId}.${webRouter['methodName']}`,
                            controllerId,
                            middleware: [],
                            controllerMiddleware: [],
                            requestMetadata: [],
                            responseMetadata: [],
                            functionName: webRouter['functionName'],
                            functionTriggerName: webRouter['type'],
                            functionTriggerMetadata: webRouter['metadata'],
                            functionMetadata: {
                                functionName: webRouter['functionName'],
                                ...functionMeta,
                            },
                        });
                    }
                }
            }
            else {
                // 老的 @Func 写法
                if (webRouter['path'] || webRouter['middleware']) {
                    const data = {
                        prefix,
                        routerName: '',
                        url: (_e = webRouter['path']) !== null && _e !== void 0 ? _e : '',
                        requestMethod: (_f = webRouter['method']) !== null && _f !== void 0 ? _f : 'get',
                        method: (_g = webRouter['key']) !== null && _g !== void 0 ? _g : '',
                        description: '',
                        summary: '',
                        handlerName: `${controllerId}.${webRouter['key']}`,
                        funcHandlerName: webRouter['funHandler'] || `${controllerId}.${webRouter['key']}`,
                        controllerId,
                        middleware: webRouter['middleware'] || [],
                        controllerMiddleware: [],
                        requestMetadata: [],
                        responseMetadata: [],
                    };
                    if (functionMeta) {
                        // get function information
                        data.functionName = controllerId + '-' + ((_h = webRouter['key']) !== null && _h !== void 0 ? _h : '');
                        data.functionTriggerName = decorator_1.ServerlessTriggerType.HTTP;
                        data.functionTriggerMetadata = {
                            path: (_j = webRouter['path']) !== null && _j !== void 0 ? _j : '/',
                            method: (_k = webRouter['method']) !== null && _k !== void 0 ? _k : 'get',
                        };
                        data.functionMetadata = {
                            functionName: data.functionName,
                        };
                    }
                    // 老函数的 http
                    this.checkDuplicateAndPush(prefix, data);
                }
                else {
                    if (functionMeta) {
                        // 非 http
                        this.checkDuplicateAndPush(prefix, {
                            prefix,
                            routerName: '',
                            url: '',
                            requestMethod: '',
                            method: webRouter['key'],
                            description: '',
                            summary: '',
                            handlerName: `${controllerId}.${webRouter['key']}`,
                            funcHandlerName: webRouter['funHandler'] ||
                                `${controllerId}.${webRouter['key']}`,
                            controllerId,
                            middleware: webRouter['middleware'] || [],
                            controllerMiddleware: [],
                            requestMetadata: [],
                            responseMetadata: [],
                            functionName: webRouter['functionName'],
                            functionTriggerName: webRouter['type'],
                            functionTriggerMetadata: webRouter['metadata'],
                            functionMetadata: {
                                functionName: webRouter['functionName'],
                            },
                        });
                    }
                }
            }
        }
    }
    sortRouter(urlMatchList) {
        // 1. 绝对路径规则优先级最高如 /ab/cb/e
        // 2. 星号只能出现最后且必须在/后面，如 /ab/cb/**
        // 3. 如果绝对路径和通配都能匹配一个路径时，绝对规则优先级高
        // 4. 有多个通配能匹配一个路径时，最长的规则匹配，如 /ab/** 和 /ab/cd/** 在匹配 /ab/cd/f 时命中 /ab/cd/**
        // 5. 如果 / 与 /* 都能匹配 / ,但 / 的优先级高于 /*
        return urlMatchList
            .map(item => {
            const urlString = item.url.toString();
            const weightArr = (0, decorator_1.isRegExp)(item.url)
                ? urlString.split('\\/')
                : urlString.split('/');
            let weight = 0;
            // 权重，比如通配的不加权，非通配加权，防止通配出现在最前面
            for (const fragment of weightArr) {
                if (fragment === '' ||
                    fragment.includes(':') ||
                    fragment.includes('*')) {
                    weight += 0;
                }
                else {
                    weight += 1;
                }
            }
            let category = 2;
            const paramString = urlString.includes(':')
                ? urlString.replace(/:.+$/, '')
                : '';
            if (paramString) {
                category = 1;
            }
            if (urlString.includes('*')) {
                category = 0;
            }
            return {
                ...item,
                _pureRouter: urlString.replace(/\**$/, '').replace(/:\w+/, '123'),
                _level: urlString.split('/').length - 1,
                _paramString: paramString,
                _category: category,
                _weight: weight,
            };
        })
            .sort((handlerA, handlerB) => {
            // 不同一层级的对比
            if (handlerA._category !== handlerB._category) {
                return handlerB._category - handlerA._category;
            }
            // 不同权重
            if (handlerA._weight !== handlerB._weight) {
                return handlerB._weight - handlerA._weight;
            }
            // 不同长度
            if (handlerA._level === handlerB._level) {
                if (handlerB._pureRouter === handlerA._pureRouter) {
                    return (handlerA.url.toString().length - handlerB.url.toString().length);
                }
                return handlerB._pureRouter.length - handlerA._pureRouter.length;
            }
            return handlerB._level - handlerA._level;
        });
    }
    async getRoutePriorityList() {
        if (!this.isReady) {
            await this.analyze();
            this.isReady = true;
        }
        return this.routesPriority;
    }
    async getRouterTable() {
        if (!this.isReady) {
            await this.analyze();
            this.isReady = true;
        }
        return this.routes;
    }
    async getFlattenRouterTable() {
        if (!this.isReady) {
            await this.analyze();
            this.isReady = true;
        }
        let routeArr = [];
        for (const routerInfo of this.routes.values()) {
            routeArr = routeArr.concat(routerInfo);
        }
        return routeArr;
    }
    checkDuplicateAndPush(prefix, routerInfo) {
        const prefixList = this.routes.get(prefix);
        const matched = prefixList.filter(item => {
            return (routerInfo.url &&
                routerInfo.requestMethod &&
                item.url === routerInfo.url &&
                item.requestMethod === routerInfo.requestMethod);
        });
        if (matched && matched.length) {
            throw new Error(`Duplicate router "${routerInfo.requestMethod} ${routerInfo.url}" at "${matched[0].handlerName}" and "${routerInfo.handlerName}"`);
        }
        prefixList.push(routerInfo);
    }
}
exports.WebRouterCollector = WebRouterCollector;
//# sourceMappingURL=webRouterCollector.js.map