"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pipelineFactory = exports.PipelineHandler = exports.PipelineContext = void 0;
const decorator_1 = require("@midwayjs/decorator");
const providerWrapper_1 = require("../context/providerWrapper");
class PipelineContext {
    constructor(args) {
        this.info = { current: null };
        this.data = new Map();
        this.args = args;
    }
    get(key) {
        return this.data.get(key);
    }
    set(key, val) {
        this.data.set(key, val);
    }
    keys() {
        const keys = [];
        const iter = this.data.keys();
        for (const k of iter) {
            keys.push(k);
        }
        return keys;
    }
}
exports.PipelineContext = PipelineContext;
class PipelineHandler {
    constructor(applicationContext, valves) {
        this.applicationContext = applicationContext;
        this.valves = valves;
    }
    async parallel(opts) {
        const valves = this.prepareParallelValves(opts);
        const res = await Promise.all(valves);
        return this.packResult(res, false);
    }
    async concat(opts) {
        const valves = this.prepareParallelValves(opts);
        const res = await Promise.all(valves);
        return this.packResult(res, true);
    }
    async series(opts) {
        const valves = this.mergeValves(opts.valves);
        const ctx = new PipelineContext(opts.args);
        const result = { success: true, result: null };
        const data = {};
        const info = {
            prevValue: null,
            current: null,
            prev: null,
            next: null,
        };
        let nextIdx = 1;
        for (const v of valves) {
            info.prev = info.current;
            info.current = v;
            if (nextIdx < valves.length) {
                info.next = valves[nextIdx];
            }
            else {
                info.next = undefined;
            }
            nextIdx += 1;
            ctx.info = info;
            try {
                const inst = await this.applicationContext.getAsync(v);
                const tmpValue = await inst.invoke(ctx);
                let key = v;
                if (inst.alias) {
                    key = inst.alias;
                }
                data[key] = tmpValue;
                info.prevValue = tmpValue;
            }
            catch (e) {
                result.success = false;
                result.error = {
                    valveName: v,
                    message: e.message,
                    error: e,
                };
                return result;
            }
        }
        result.result = data;
        return result;
    }
    async concatSeries(opts) {
        const valves = this.mergeValves(opts.valves);
        const ctx = new PipelineContext(opts.args);
        const result = { success: true, result: null };
        const data = [];
        const info = {
            prevValue: null,
            current: null,
            prev: null,
            next: null,
        };
        let nextIdx = 1;
        for (const v of valves) {
            info.prev = info.current;
            info.current = v;
            if (nextIdx < valves.length) {
                info.next = valves[nextIdx];
            }
            else {
                info.next = undefined;
            }
            nextIdx += 1;
            ctx.info = info;
            try {
                const inst = await this.applicationContext.getAsync(v);
                const tmpValue = await inst.invoke(ctx);
                data.push(tmpValue);
                info.prevValue = tmpValue;
            }
            catch (e) {
                result.success = false;
                result.error = {
                    valveName: v,
                    message: e.message,
                    error: e,
                };
                return result;
            }
        }
        result.result = data;
        return result;
    }
    async waterfall(opts) {
        const result = await this.concatSeries(opts);
        if (result.success) {
            const data = result.result;
            result.result = data[data.length - 1];
        }
        return result;
    }
    mergeValves(valves) {
        let items = [];
        if (this.valves && this.valves.length > 0) {
            items = this.valves;
        }
        let newItems = [];
        if (valves) {
            for (const v of valves) {
                if (items.includes(v)) {
                    newItems.push(v);
                }
            }
        }
        else {
            newItems = items;
        }
        return newItems;
    }
    prepareParallelValves(opts) {
        const valves = this.mergeValves(opts.valves);
        const ctx = new PipelineContext(opts.args);
        return valves.map(async (v) => {
            const rt = { valveName: v, dataKey: v, data: null };
            try {
                const inst = await this.applicationContext.getAsync(v);
                if (inst.alias) {
                    rt.dataKey = inst.alias;
                }
                rt.data = await inst.invoke(ctx);
            }
            catch (e) {
                rt.error = e;
            }
            return rt;
        });
    }
    packResult(res, resultIsArray = false) {
        const result = { success: true, result: null };
        let data;
        if (resultIsArray) {
            data = [];
        }
        else {
            data = {};
        }
        for (const r of res) {
            if (r.error) {
                result.success = false;
                result.error = {
                    valveName: r.valveName,
                    message: r.error.message,
                    error: r.error,
                };
                return result;
            }
            else {
                if (resultIsArray) {
                    data.push(r.data);
                }
                else {
                    data[r.dataKey] = r.data;
                }
            }
        }
        result.result = data;
        return result;
    }
}
exports.PipelineHandler = PipelineHandler;
function pipelineFactory(applicationContext, valves) {
    return new PipelineHandler(applicationContext, valves);
}
exports.pipelineFactory = pipelineFactory;
(0, providerWrapper_1.providerWrapper)([
    {
        id: decorator_1.PIPELINE_IDENTIFIER,
        provider: pipelineFactory,
        scope: decorator_1.ScopeEnum.Prototype,
    },
]);
//# sourceMappingURL=pipeline.js.map